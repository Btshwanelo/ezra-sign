<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document Template Creator</title>
    <style>
      /* Base styles */
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background: #f8fafc; /* slate-50 */
        color: #334155; /* slate-700 */
      }

      .app-container {
        width: 100%;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      /* Utility classes */
      .text-sm {
        font-size: 0.875rem;
      }

      .text-slate-500 {
        color: #64748b;
      }

      .text-slate-800 {
        color: #1e293b;
      }

      .font-medium {
        font-weight: 500;
      }

      /* Header/Toolbar styles */
      .toolbar {
        padding: 0.75rem 1rem;
        background: #2563eb;
        border-bottom: 1px solid #e2e8f0; /* slate-200 */
        display: flex;
        gap: 1rem;
        align-items: center;
        height: 48px;
      }

      .page-selector {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-right: auto;
      }

      .page-select {
        padding: 0.375rem 0.5rem;
        border: none; /* slate-200 */
        border-radius: 0.375rem;
        background-color: inherit;
        font-size: 0.875rem;
        color: #dbeafe; /* slate-700 */
        outline: none;
        transition: all 0.2s;
      }

      .page-select:focus {
        border-color: #3b82f6; /* blue-500 */
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
      }

      /* Button styles */
      .btn-primary {
        padding: 0.5rem 1rem;
        background: inherit; /* blue-600 */
        color: #dbeafe;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .btn-primary:hover {
        background: #1d4ed8; /* blue-700 */
      }

      .btn-outline {
        padding: 0.5rem 1rem;
        background: inherit;
        color: #dbeafe; /* slate-600 */
        border: none; /* slate-200 */
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-outline:hover {
        background: #f8fafc; /* slate-50 */
        border-color: #cbd5e1; /* slate-300 */
      }

      .btn-outline-full {
        width: 100%;
        padding: 0.5rem 1rem;
        background: white;
        color: #2563eb; /* blue-600 */
        border: 1px solid #2563eb; /* blue-600 */
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-outline-full:hover {
        background: #eff6ff; /* blue-50 */
      }

      /* Main content layout */
      .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      /* Sidebar styles */
      .sidebar {
        width: 320px;
        background: white;
        border-right: 1px solid #e2e8f0; /* slate-200 */
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .sidebar-header {
        padding: 1rem;
        border-bottom: 1px solid #e2e8f0; /* slate-200 */
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .template-title {
        font-size: 1rem;
        font-weight: 600;
        color: #1e293b; /* slate-800 */
      }

      /* Step Navigation */
      .step-nav {
        padding: 1rem;
        border-bottom: 1px solid #e2e8f0;
      }

      .step-nav-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .step-nav-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.2s;
      }

      .step-nav-item:hover {
        background: #f8fafc; /* slate-50 */
      }

      .step-nav-item.active {
        background: #eff6ff; /* blue-50 */
        border-left: 3px solid #2563eb; /* blue-600 */
      }

      .step-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #e2e8f0; /* slate-200 */
        color: #475569; /* slate-600 */
        font-size: 0.75rem;
        font-weight: 600;
      }

      .step-nav-item.active .step-indicator,
      .step-nav-item.completed .step-indicator {
        background: #2563eb; /* blue-600 */
        color: white;
      }

      .step-nav-item.completed .step-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .step-title {
        font-weight: 500;
        font-size: 0.875rem;
      }

      .step-content {
        padding: 1rem;
        overflow-y: auto;
        flex: 1;
      }

      /* Recipients Section */
      .recipients-section {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .section-title {
        font-size: 0.875rem;
        font-weight: 600;
        color: #1e293b; /* slate-800 */
        margin-bottom: 0.5rem;
      }

      .recipients-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .recipient-item {
        display: flex;
        align-items: center;
        padding: 0.75rem;
        background: #f8fafc; /* slate-50 */
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem;
        position: relative;
      }

      .recipient-info {
        flex: 1;
      }

      .recipient-label {
        font-weight: 500;
        font-size: 0.875rem;
        margin-bottom: 0.25rem;
      }

      .recipient-type {
        font-size: 0.75rem;
        color: #64748b; /* slate-500 */
      }

      .recipient-actions {
        display: flex;
        gap: 0.5rem;
      }

      .action-btn {
        background: none;
        border: none;
        cursor: pointer;
        color: #64748b; /* slate-500 */
        transition: color 0.2s;
        padding: 0.25rem;
      }

      .action-btn:hover {
        color: #2563eb; /* blue-600 */
      }

      .delete-btn:hover {
        color: #ef4444; /* red-500 */
      }

      /* Fields Section */
      .field-selector {
        margin-bottom: 1rem;
      }

      .field-category {
        margin-bottom: 1rem;
      }

      .field-category-title {
        font-size: 0.75rem;
        color: #64748b; /* slate-500 */
        text-transform: uppercase;
        margin-bottom: 0.75rem;
        font-weight: 500;
        letter-spacing: 0.05em;
      }

      .field-type-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }

      .field-type-button {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0.75rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem;
        cursor: pointer;
        background: white;
        transition: all 0.2s;
      }

      .field-type-button:hover {
        background: #f8fafc; /* slate-50 */
        border-color: #2563eb; /* blue-600 */
        color: #2563eb; /* blue-600 */
      }

      .field-type-button.selected {
        border-color: #2563eb; /* blue-600 */
        background: #eff6ff; /* blue-50 */
        color: #2563eb; /* blue-600 */
      }

      .field-type-icon {
        width: 24px;
        height: 24px;
        margin-bottom: 0.375rem;
        color: currentColor;
      }

      .field-type-label {
        font-size: 0.75rem;
        color: currentColor;
        text-align: center;
      }

      /* Document viewer styles */
      .document-viewer {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background-color: #f8fafc; /* slate-50 */
        max-width: 1200px; /* Add max-width constraint */
        margin: 0 auto; /* Center the container */
        width: 100%; /* Ensure it takes full width up to max-width */
      }

      .page-container {
        position: relative;
        background-color: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        border-radius: 0.25rem;
        max-width: 100%; /* Ensure page container doesn't exceed viewer width */
      }

      #pdfCanvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 0.25rem;
        max-width: 100%; /* Ensure canvas doesn't exceed container width */
      }

      .fields-layer {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        width: 100%; /* Ensure fields layer matches canvas width */
        height: 100%;
      }

      /* Field styles */
      .field {
        position: absolute;

        cursor: pointer;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
        pointer-events: auto;
      }

      .field:hover {
        background-color: rgba(
          37,
          99,
          235,
          0.1
        ); /* blue-600 with more opacity */
      }

      .field-content {
        position: relative;
        width: 100%;
        /* height: 100%; */
      }

      .field-label {
        position: absolute;
        top: -20px;
        left: 0;
        font-size: 0.75rem;
        color: #2563eb; /* blue-600 */
        font-weight: 500;
      }

      .delete-button {
        position: absolute;
        top: -20px;
        right: 0;
        background: none;
        border: none;
        color: #ef4444; /* red-500 */
        cursor: pointer;
        font-size: 16px;
        padding: 0;
      }

      .resize-handle {
        position: absolute;
        bottom: -5px;
        right: -5px;
        width: 10px;
        height: 10px;
        background-color: #2563eb; /* blue-600 */
        cursor: nwse-resize;
        border-radius: 50%;
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(15, 23, 42, 0.5); /* slate-900 with opacity */
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .modal.show {
        display: flex !important;
        align-items: center;
        justify-content: center;
        opacity: 1;
      }

      .modal-content {
        background-color: white;
        padding: 1.5rem;
        border-radius: 0.5rem;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        position: relative;
        z-index: 1001;
      }

      .modal-title {
        margin-top: 0;
        margin-bottom: 1.25rem;
        color: #1e293b; /* slate-800 */
        font-size: 1.125rem;
        font-weight: 600;
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.375rem;
        color: #475569; /* slate-600 */
        font-size: 0.875rem;
        font-weight: 500;
      }

      .form-input {
        width: 100%;
        height: 40px;
        padding: 0.1rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem;
        font-size: 0.875rem;
        color: #334155; /* slate-700 */
        transition: all 0.2s;
      }

      .form-input:focus {
        outline: none;
        border-color: #2563eb; /* blue-600 */
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
      }

      .form-select {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem;
        font-size: 0.875rem;
        color: #334155; /* slate-700 */
        background-color: white;
        transition: all 0.2s;
      }

      .form-select:focus {
        outline: none;
        border-color: #2563eb; /* blue-600 */
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
      }

      .form-checkbox {
        width: 1rem;
        height: 1rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.25rem;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        margin-top: 1.5rem;
      }

      /* Signer View Selector */
      .signer-selector {
        padding: 0.75rem 0;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e2e8f0;
      }

      .signer-selector-label {
        font-size: 0.75rem;
        color: #64748b;
        margin-bottom: 0.375rem;
      }

      /* Simplified checkboxes */
      .field[data-type="checkbox"] .field-content {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        padding: 0.5rem;
        position: relative;
      }

      .checkbox-container {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        width: 100%;
        position: relative;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 0.25rem;
        cursor: move;
        transition: all 0.2s;
        position: absolute;
        width: fit-content;
      }

      .field-checkbox {
        width: 1rem;
        height: 1rem;
        cursor: pointer;
        border: 1px solid #94a3b8; /* slate-400 */
        border-radius: 0.25rem;
      }

      /* Step Nav Bottom Buttons */
      .step-nav-buttons {
        padding: 1rem;
        display: flex;
        gap: 0.75rem;
        border-top: 1px solid #e2e8f0;
      }

      .btn-back {
        flex: 1;
      }

      .btn-next {
        flex: 1;
      }

      /* Completed step indicator */
      .check-icon {
        width: 16px;
        height: 16px;
      }

      /* Empty state for recipients */
      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
        text-align: center;
        background: #f8fafc;
        border-radius: 0.5rem;
        border: 1px dashed #cbd5e1;
      }

      .empty-state-icon {
        color: #94a3b8;
        margin-bottom: 1rem;
      }

      .empty-state-text {
        color: #64748b;
        font-size: 0.875rem;
        margin-bottom: 1rem;
      }

      .field[data-type="checkbox_group"] .field-content {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        padding: 0.5rem;
        position: relative;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <!-- Header/Toolbar -->
      <div class="toolbar">
        <div>
          <button
            id="goBackButton"
            onclick="window.location.href='/templates'"
            class="btn-outline"
          >
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <line x1="19" y1="12" x2="5" y2="12"></line>
              <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
            Go Back
          </button>
        </div>
        <div class="page-selector">
          <!-- <span class="text-slate-500 text-sm">Page:</span> -->
          <select id="pageSelector" class="page-select">
            <!-- Pages will be added dynamically -->
          </select>
        </div>
        <button id="saveButton" class="btn-primary">Save Template</button>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Sidebar -->
        <div class="sidebar">
          <div class="sidebar-header">
            <div class="template-title">Document Template</div>
            <span class="text-sm text-slate-500"
              >Configure signers and fields</span
            >
          </div>

          <!-- Step Navigation -->
          <div class="step-nav">
            <ul class="step-nav-list">
              <li class="step-nav-item active" id="step1Item" data-step="1">
                <div class="step-indicator">1</div>
                <div class="step-title">Configure Recipients</div>
              </li>
              <li class="step-nav-item" id="step2Item" data-step="2">
                <div class="step-indicator">2</div>
                <div class="step-title">Add Document Fields</div>
              </li>
            </ul>
          </div>

          <!-- Step Content -->
          <div class="step-content">
            <!-- Step 1: Recipients Configuration -->
            <div id="step1Content" class="recipients-section">
              <div class="section-title">Recipients</div>
              <p class="text-sm text-slate-500">
                Add the people who will receive this document for signature or
                review.
              </p>

              <div id="recipientsList" class="recipients-list">
                <!-- Recipients will be dynamically added here -->
                <!-- Empty state when no recipients -->
                <div id="emptyRecipientsState" class="empty-state">
                  <svg
                    class="empty-state-icon"
                    width="48"
                    height="48"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                  </svg>
                  <div class="empty-state-text">No recipients added yet</div>
                  <button id="addFirstRecipient" class="btn-primary">
                    Add Recipient
                  </button>
                </div>
              </div>

              <div
                class="form-group"
                id="addRecipientBtnContainer"
                style="display: none"
              >
                <button
                  id="addRecipient"
                  class="btn-outline-full"
                  style="margin-top: 1rem"
                >
                  Add Another Recipient
                </button>
              </div>
            </div>

            <!-- Step 2: Field Configuration -->
            <div id="step2Content" class="fields-section" style="display: none">
              <!-- Signer Selector -->
              <div class="signer-selector">
                <div class="signer-selector-label">Adding fields for:</div>
                <select id="signerSelector" class="form-select">
                  <!-- Signers will be added dynamically -->
                </select>
              </div>

              <!-- Field Type Selector -->
              <div class="field-category">
                <div class="field-category-title">Standard Fields</div>
                <div class="field-type-grid">
                  <button class="field-type-button" data-field-type="signature">
                    <svg class="field-type-icon" viewBox="0 0 24 24">
                      <path
                        fill="currentColor"
                        d="M22,3H2A1,1 0 0,0 1,4V20A1,1 0 0,0 2,21H22A1,1 0 0,0 23,20V4A1,1 0 0,0 22,3M21,19H3V5H21V19M17,17H7V7H17V17M15,9H9V15H15V9"
                      ></path>
                    </svg>
                    <span class="field-type-label">Signature</span>
                  </button>

                  <button class="field-type-button" data-field-type="initials">
                    <svg class="field-type-icon" viewBox="0 0 24 24">
                      <path
                        fill="currentColor"
                        d="M2,6V8H14V6H2M2,10V12H14V10H2M20.04,10.13C19.9,10.13 19.76,10.19 19.65,10.3L18.65,11.3L20.7,13.35L21.7,12.35C21.92,12.14 21.92,11.79 21.7,11.58L20.42,10.3C20.31,10.19 20.18,10.13 20.04,10.13M18.07,11.88L12,17.94V20H14.06L20.12,13.93L18.07,11.88M2,14V16H10V14H2Z"
                      ></path>
                    </svg>
                    <span class="field-type-label">Initials</span>
                  </button>

                  <button class="field-type-button" data-field-type="text">
                    <svg class="field-type-icon" viewBox="0 0 24 24">
                      <path
                        fill="currentColor"
                        d="M14,17H7V15H14M17,13H7V11H17M17,9H7V7H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z"
                      ></path>
                    </svg>
                    <span class="field-type-label">Text</span>
                  </button>

                  <button class="field-type-button" data-field-type="date">
                    <svg class="field-type-icon" viewBox="0 0 24 24">
                      <path
                        fill="currentColor"
                        d="M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1M17,12H12V17H17V12Z"
                      ></path>
                    </svg>
                    <span class="field-type-label">Date</span>
                  </button>

                  <button
                    class="field-type-button"
                    data-field-type="checkbox_group"
                  >
                    <svg class="field-type-icon" viewBox="0 0 24 24">
                      <path
                        fill="currentColor"
                        d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19M10,17L6,13L7.41,11.59L10,14.17L16.59,7.58L18,9"
                      ></path>
                    </svg>
                    <span class="field-type-label">Checkbox</span>
                  </button>
                </div>
              </div>

              <!-- Field information -->
              <div class="text-sm text-slate-500 mt-4">
                <p>
                  Click on a field type above, then click on the document to
                  place it. Fields can be moved and resized.
                </p>
              </div>
            </div>
          </div>

          <!-- Step Navigation Buttons -->
          <div class="step-nav-buttons">
            <button
              id="backButton"
              class="btn-outline btn-back"
              style="display: none"
            >
              Back
            </button>
            <button id="nextButton" class="btn-primary btn-next">
              Next: Add Fields
            </button>
          </div>
        </div>

        <!-- Document Viewer -->
        <div class="document-viewer">
          <div class="page-container">
            <canvas id="pdfCanvas"></canvas>
            <div id="fieldsLayer" class="fields-layer"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Recipient Modal -->
    <div id="recipientModal" class="modal">
      <div class="modal-content">
        <h3 class="modal-title">Add Recipient</h3>
        <div class="form-group">
          <label class="form-label">Type</label>
          <select id="recipientType" class="form-select">
            <option value="signer">Signer</option>
            <option value="viewer">Viewer</option>
            <option value="approver">Approver</option>
          </select>
        </div>
        <div class="form-group" id="signerLabelGroup">
          <label class="form-label">Label</label>
          <input
            type="text"
            id="recipientLabel"
            class="form-input"
            placeholder="e.g., Landlord, Student, Employer"
          />
        </div>
        <div class="modal-actions">
          <button id="cancelRecipient" class="btn-outline">Cancel</button>
          <button id="saveRecipient" class="btn-primary">Add</button>
        </div>
      </div>
    </div>

    <!-- Field Configuration Modal -->
    <div id="fieldConfigModal" class="modal">
      <div class="modal-content">
        <h3 class="modal-title">Configure Field</h3>
        <div class="form-group">
          <label class="form-label">Field Type</label>
          <select id="fieldType" class="form-select">
            <option value="signature">Signature</option>
            <option value="initials">Initials</option>
            <option value="checkbox_group">Checkbox Group</option>
            <option value="text">Text</option>
            <option value="date">Date</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Label</label>
          <input
            type="text"
            id="fieldLabel"
            placeholder="Enter field label"
            class="form-input"
          />
        </div>
        <div class="form-group">
          <label class="form-label">Required</label>
          <input type="checkbox" id="fieldRequired" class="form-checkbox" />
        </div>
        <!-- Add styling properties -->
        <div class="form-group">
          <label class="form-label">Color</label>
          <input
            type="color"
            id="fieldColor"
            class="form-input"
            value="#000000"
          />
        </div>
        <div class="form-group">
          <label class="form-label">Font Size</label>
          <input
            type="number"
            id="fieldFontSize"
            class="form-input"
            value="12"
            min="8"
            max="72"
          />
        </div>
        <div class="form-group">
          <label class="form-label">Font</label>
          <select id="fieldFont" class="form-select">
            <option value="Arial">Arial</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Courier New">Courier New</option>
          </select>
        </div>
        <div id="textLengthConfig" class="form-group" style="display: none">
          <label class="form-label">Expected Text Length</label>
          <select id="textLength" class="form-select">
            <option value="short">Short (1-20 characters)</option>
            <option value="medium">Medium (21-50 characters)</option>
            <option value="long">Long (51-100 characters)</option>
            <option value="very_long">Very Long (101-200 characters)</option>
          </select>
        </div>
        <div id="checkboxConfig" class="form-group" style="display: none">
          <label class="form-label">Total Checkboxes</label>
          <input
            type="number"
            id="totalCheckboxes"
            min="1"
            value="1"
            class="form-input"
          />
          <label class="form-label">Required Checkboxes</label>
          <input
            type="number"
            id="requiredCheckboxes"
            min="0"
            value="1"
            class="form-input"
          />
        </div>
        <div class="modal-actions">
          <button id="deleteField" class="btn-outline" style="display: none">
            Delete Field
          </button>
          <button id="cancelField" class="btn-outline">Cancel</button>
          <button id="saveField" class="btn-primary">Create</button>
        </div>
      </div>
    </div>

    <!-- Checkbox Configuration Modal -->
    <div id="checkboxConfigModal" class="modal">
      <div class="modal-content">
        <h3 class="modal-title">Configure Checkbox Group</h3>
        <div class="form-group">
          <label for="totalCheckboxes" class="form-label"
            >Total Number of Checkboxes:</label
          >
          <input
            type="number"
            id="totalCheckboxes"
            min="1"
            value="1"
            class="form-input"
          />
        </div>
        <div class="form-group">
          <label for="requiredCheckboxes" class="form-label"
            >Number of Required Checkboxes:</label
          >
          <input
            type="number"
            id="requiredCheckboxes"
            min="0"
            value="0"
            class="form-input"
          />
        </div>
        <div class="modal-actions">
          <button id="cancelCheckboxConfig" class="btn-outline">Cancel</button>
          <button id="saveCheckboxConfig" class="btn-primary">Save</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Get API URL from environment
      const API_URL = window.ENV?.VITE_API_URL || 'https://ezra360sign-api.mnt.ezra360.com/api';
      // const API_URL = window.ENV?.VITE_API_URL || 'http://localhost:5000/api';
      
      // Initialize PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      // Wait for DOM to be fully loaded
      document.addEventListener("DOMContentLoaded", async () => {
        // DOM elements
        const documentViewer = document.querySelector(".document-viewer");
        const fieldsLayer = document.getElementById("fieldsLayer");
        const fieldTypeButtons =
          document.querySelectorAll(".field-type-button");
        const saveButton = document.getElementById("saveButton");
        const pageSelector = document.getElementById("pageSelector");
        const step1Item = document.getElementById("step1Item");
        const step2Item = document.getElementById("step2Item");
        const step1Content = document.getElementById("step1Content");
        const step2Content = document.getElementById("step2Content");
        const nextButton = document.getElementById("nextButton");
        const backButton = document.getElementById("backButton");
        const signerSelector = document.getElementById("signerSelector");
        const recipientsList = document.getElementById("recipientsList");
        const emptyRecipientsState = document.getElementById(
          "emptyRecipientsState"
        );
        const addRecipientBtnContainer = document.getElementById(
          "addRecipientBtnContainer"
        );
        const addFirstRecipientBtn =
          document.getElementById("addFirstRecipient");
        const addRecipientBtn = document.getElementById("addRecipient");

        // Modal elements
        const recipientModal = document.getElementById("recipientModal");
        const fieldConfigModal = document.getElementById("fieldConfigModal");
        const checkboxConfigModal = document.getElementById(
          "checkboxConfigModal"
        );
        const recipientTypeSelect = document.getElementById("recipientType");
        const recipientLabelInput = document.getElementById("recipientLabel");
        const signerLabelGroup = document.getElementById("signerLabelGroup");
        const saveRecipientBtn = document.getElementById("saveRecipient");
        const cancelRecipientBtn = document.getElementById("cancelRecipient");
        const fieldTypeSelect = document.getElementById("fieldType");
        const fieldLabelInput = document.getElementById("fieldLabel");
        const fieldRequiredCheckbox = document.getElementById("fieldRequired");
        const checkboxConfigDiv = document.getElementById("checkboxConfig");
        const cancelFieldBtn = document.getElementById("cancelField");
        const saveFieldBtn = document.getElementById("saveField");
        const totalCheckboxesInput = document.getElementById("totalCheckboxes");
        const requiredCheckboxesInput =
          document.getElementById("requiredCheckboxes");
        const textLengthConfig = document.getElementById("textLengthConfig");

        // Check if all required DOM elements exist
        if (!documentViewer || !fieldsLayer || !saveButton) {
          console.error(
            "Required DOM elements not found. Please check your HTML structure."
          );
          throw new Error("Required DOM elements not found");
        }

        // State
        let currentPdf = null;
        let currentPage = null;
        let currentScale = 1.0;
        let fields = [];
        let activeField = null;
        let isDragging = false;
        let isResizing = false;
        let initialMousePos = { x: 0, y: 0 };
        let initialFieldPos = { x: 0, y: 0 };
        let initialFieldSize = { width: 0, height: 0 };
        let selectedFieldType = "signature"; // Default field type
        let currentPageNumber = 1; // Track current page number
        let documentUrl = null;
        let signers = []; // Initialize signers array
        let recipients = []; // Initialize recipients array
        let initialRecipients = []; // Store initial recipients for comparison
        let currentStep = 1; // Current step (1 or 2)
        let selectedSignerTypeId = null; // Currently selected signer for field placement
        let isEditingRecipient = false; // Flag to check if editing an existing recipient
        let currentEditingRecipientId = null; // ID of recipient being edited
        let hasRecipientsChanged = false; // Flag to track if recipients have been modified
        let isCheckboxDragging = false;
        let activeCheckbox = null;
        let activeCheckboxField = null;
        let activeCheckboxIndex = null;

        // Event Listeners for Step Navigation
        step1Item.addEventListener("click", () => goToStep(1));
        step2Item.addEventListener("click", () => {
          if (recipients.length > 0) {
            goToStep(2);
          } else {
            alert(
              "Please add at least one recipient before proceeding to step 2."
            );
          }
        });

        nextButton.addEventListener("click", () => {
          if (currentStep === 1) {
            if (recipients.length > 0) {
              goToStep(2);
            } else {
              alert(
                "Please add at least one recipient before proceeding to step 2."
              );
            }
          } else {
            // If we're on step 2, next would be save
            saveTemplate();
          }
        });

        backButton.addEventListener("click", () => {
          if (currentStep === 2) {
            goToStep(1);
          }
        });

        // Event listeners for recipient management
        addFirstRecipientBtn.addEventListener("click", showAddRecipientModal);
        addRecipientBtn.addEventListener("click", showAddRecipientModal);
        saveRecipientBtn.addEventListener("click", saveRecipient);
        cancelRecipientBtn.addEventListener("click", hideRecipientModal);

        // Event listener for recipient type change
        recipientTypeSelect.addEventListener("change", function () {
          const isSignerType = this.value === "signer";
          signerLabelGroup.style.display = isSignerType ? "block" : "none";
        });

        // Event listener for field type change
        fieldTypeSelect.addEventListener("change", function () {
          const isCheckboxType = this.value === "checkbox_group";
          const isTextType = this.value === "text";
          checkboxConfigDiv.style.display = isCheckboxType ? "block" : "none";
          textLengthConfig.style.display = isTextType ? "block" : "none";
        });

        // Event listeners for field configuration
        cancelFieldBtn.addEventListener("click", hideFieldConfigModal);
        saveFieldBtn.addEventListener("click", createField);

        // Event listeners for field type buttons
        fieldTypeButtons.forEach((button) => {
          button.addEventListener("click", () => {
            // Remove selected class from all buttons
            fieldTypeButtons.forEach((btn) => btn.classList.remove("selected"));
            // Add selected class to clicked button
            button.classList.add("selected");
            // Update selected field type
            selectedFieldType = button.dataset.fieldType;
            // Store that we're in field creation mode
            isCreatingField = true;
          });
        });

        // Event listener for signer selector
        signerSelector.addEventListener("change", function () {
          selectedSignerTypeId = this.value;
          updateFieldsDisplay();
        });

        // Add save button click handler
        saveButton.addEventListener("click", saveTemplate);

        // Get document ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const templateId = urlParams.get("id");
        const isTemplate = !!templateId;
        const documentId = isTemplate ? templateId : urlParams.get("id");

        const token = localStorage.getItem("token");
        if (!token) {
          alert("Please log in to access this page");
          window.location.href = "/auth/login";
          return;
        }

        // Load document based on ID from URL
        if (isTemplate) {
          // Load template document
          try {
            const response = await fetch(`${API_URL}/templates/${templateId}`, {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });
            if (!response.ok) {
              throw new Error("Failed to load template");
            }
            const data = await response.json();

            if (!data.success) {
              throw new Error(data.message || "Failed to load template");
            }

            // Extract template from the response
            const template = data.template;
            documentUrl = template.fileUrl;

            console.log("Template loaded:", template);

            // Load signers from template
            if (template.signerTypes && template.signerTypes.length > 0) {
              signers = template.signerTypes.map((st) => ({
                id: st._id,
                type: st.type,
                label: st.label,
                order: st.order,
              }));
              recipients = [...signers];
              initialRecipients = JSON.parse(JSON.stringify(recipients)); // Store initial state
              updateRecipientsDisplay();
            }

            // Load fields from template - if they exist
            if (template.fields && template.fields.length > 0) {
              fields = template.fields;
            }

            // Ensure we have a valid document URL before trying to load
            if (documentUrl) {
              await loadDocument();
            } else {
              console.error("No document URL found");
              alert("Failed to load document: No document URL found");
            }
          } catch (error) {
            console.error("Error loading template:", error);
            alert("Failed to load template: " + error.message);
          }
        } else if (documentId) {
          // Existing document loading logic
          try {
            const response = await fetch(`${API_URL}/documents/${documentId}`, {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });
            if (!response.ok) {
              throw new Error("Failed to load document");
            }
            const document = await response.json();
            documentUrl = document.data.fileUrl;
            await loadDocument();
          } catch (error) {
            console.error("Error loading document:", error);
            alert("Failed to load document: " + error.message);
          }
        }

        // Step Navigation Functions
        async function goToStep(step) {
          if (step === 2 && currentStep === 1) {
            // Only proceed if we have recipients
            if (recipients.length === 0) {
              alert("Please add at least one recipient before proceeding.");
              return;
            }

            try {
              // Check if we have existing signer types from the template
              const hasExistingSignerTypes = recipients.some(
                (r) => r.id && r.id.includes("_")
              );

              // Compare current recipients with initial recipients
              const recipientsChanged =
                JSON.stringify(recipients) !==
                JSON.stringify(initialRecipients);

              // If we have existing signer types and no changes were made, just proceed to step 2
              if (hasExistingSignerTypes && !recipientsChanged) {
                // Fetch latest template data
                const response = await fetch(`${API_URL}/templates/${templateId}`, {
                  headers: {
                    Authorization: `Bearer ${localStorage.getItem("token")}`,
                  },
                });

                if (!response.ok) {
                  throw new Error("Failed to fetch template data");
                }

                const data = await response.json();

                if (!data.success) {
                  throw new Error(
                    data.message || "Failed to fetch template data"
                  );
                }

                // Update recipients with latest data, including their fields
                if (data.template.signerTypes) {
                  recipients = data.template.signerTypes.map((st) => ({
                    id: st._id,
                    type: st.type,
                    label: st.label,
                    order: st.order,
                    fields: st.fields || [], // Include fields for each signer
                  }));
                  initialRecipients = JSON.parse(JSON.stringify(recipients));
                }

                // Update UI to show step 2
                step1Item.classList.remove("active");
                step1Item.classList.add("completed");
                step1Item.querySelector(".step-indicator").innerHTML = `
              <svg class="check-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
            `;
                step2Item.classList.add("active");
                step1Content.style.display = "none";
                step2Content.style.display = "block";
                nextButton.textContent = "Save Template";
                backButton.style.display = "block";

                // Update current step
                currentStep = 2;

                // Populate signer selector with existing data
                updateSignerSelector();
                return;
              }

              // If we're here, we need to update the template with new signer types
              // Prepare signer types data
              const signerTypes = recipients.map((recipient, index) => {
                // If the recipient has an ID that includes an underscore, it's an existing signer type
                if (recipient.id) {
                  return {
                    _id: recipient.id,
                    type: recipient.type,
                    label: recipient.label,
                    order: index + 1,
                  };
                } else {
                  // For new recipients, omit the _id field
                  return {
                    type: recipient.type,
                    label: recipient.label,
                    order: index + 1,
                  };
                }
              });

              console.log("Saving signer types:", signerTypes); // Add this line for debugging

              // Make API call to save/update template signer types
              const signerResponse = await fetch(
                `${API_URL}/templates/signer-types`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${localStorage.getItem("token")}`,
                  },
                  body: JSON.stringify({
                    templateId,
                    signerTypes,
                  }),
                }
              );

              if (!signerResponse.ok) {
                throw new Error("Failed to save template signer types");
              }

              const signerData = await signerResponse.json();

              if (!signerData.success) {
                throw new Error(
                  signerData.message || "Failed to save template signer types"
                );
              }

              // Fetch latest template data to get updated fields
              const templateResponse = await fetch(
                `${API_URL}/templates/${templateId}`,
                {
                  headers: {
                    Authorization: `Bearer ${localStorage.getItem("token")}`,
                  },
                }
              );

              if (!templateResponse.ok) {
                throw new Error("Failed to fetch template data");
              }

              const templateData = await templateResponse.json();

              if (!templateData.success) {
                throw new Error(
                  templateData.message || "Failed to fetch template data"
                );
              }

              // Update recipients with server response data, including their fields
              if (templateData.template.signerTypes) {
                recipients = templateData.template.signerTypes.map((st) => ({
                  id: st._id,
                  type: st.type,
                  label: st.label,
                  order: st.order,
                  fields: st.fields || [], // Include fields for each signer
                }));
              }

              // Update initial recipients after successful update
              initialRecipients = JSON.parse(JSON.stringify(recipients));

              // Update UI to show step 2
              step1Item.classList.remove("active");
              step1Item.classList.add("completed");
              step1Item.querySelector(".step-indicator").innerHTML = `
                <svg class="check-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
              `;
              step2Item.classList.add("active");
              step1Content.style.display = "none";
              step2Content.style.display = "block";
              nextButton.textContent = "Save Template";
              backButton.style.display = "block";

              // Update current step
              currentStep = 2;

              // Populate signer selector with updated data
              updateSignerSelector();
            } catch (error) {
              console.error("Error saving template signer types:", error);
              alert("Failed to save template signer types: " + error.message);
              return;
            }
          } else if (step === 1) {
            // Moving back to step 1
            currentStep = 1;
            step1Item.classList.add("active");
            step2Item.classList.remove("active");
            step2Item.classList.remove("completed");
            step1Content.style.display = "block";
            step2Content.style.display = "none";
            nextButton.textContent = "Next: Add Fields";
            backButton.style.display = "none";
          }
        }

        // Update the signer selector dropdown
        function updateSignerSelector() {
          signerSelector.innerHTML = "";
          const signerRecipients = recipients.filter(
            (r) => r.type === "signer"
          );

          if (signerRecipients.length === 0) {
            const option = document.createElement("option");
            option.textContent = "No signers available";
            option.disabled = true;
            signerSelector.appendChild(option);
          } else {
            signerRecipients.forEach((signer) => {
              const option = document.createElement("option");
              option.value = signer.id;
              option.textContent = signer.label;
              signerSelector.appendChild(option);
            });

            // Select the first signer by default
            selectedSignerTypeId = signerRecipients[0].id;
            signerSelector.value = selectedSignerTypeId;
            updateFieldsDisplay();
          }
        }

        // Recipient Management Functions
        function showAddRecipientModal() {
          recipientTypeSelect.value = "signer";
          recipientLabelInput.value = "";
          signerLabelGroup.style.display = "block";
          isEditingRecipient = false;
          currentEditingRecipientId = null;

          recipientModal.classList.add("show");
        }

        function showEditRecipientModal(recipient) {
          recipientTypeSelect.value = recipient.type;
          recipientLabelInput.value = recipient.label || "";
          signerLabelGroup.style.display =
            recipient.type === "signer" ? "block" : "none";
          isEditingRecipient = true;
          currentEditingRecipientId = recipient.id;

          recipientModal.classList.add("show");
        }

        function hideRecipientModal() {
          recipientModal.classList.remove("show");
        }

        function saveRecipient() {
          const type = recipientTypeSelect.value;
          const label = recipientLabelInput.value.trim();

          if (type === "signer" && !label) {
            alert("Please enter a label for the signer.");
            return;
          }

          if (isEditingRecipient && currentEditingRecipientId) {
            // Update existing recipient
            const index = recipients.findIndex(
              (r) => r.id === currentEditingRecipientId
            );
            if (index !== -1) {
              recipients[index] = {
                ...recipients[index],
                type,
                label:
                  type === "signer"
                    ? label
                    : `${type.charAt(0).toUpperCase() + type.slice(1)} ${
                        recipients.length + 1
                      }`,
              };
              hasRecipientsChanged = true;
            }
          } else {
            // Add new recipient without generating an ID
            const newRecipient = {
              type,
              label:
                type === "signer"
                  ? label
                  : `${type.charAt(0).toUpperCase() + type.slice(1)} ${
                      recipients.length + 1
                    }`,
              order: recipients.length + 1,
            };

            recipients.push(newRecipient);
            hasRecipientsChanged = true;
          }

          updateRecipientsDisplay();
          hideRecipientModal();
        }

        function updateRecipientsDisplay() {
          // Hide empty state if we have recipients
          if (recipients.length > 0) {
            emptyRecipientsState.style.display = "none";
            addRecipientBtnContainer.style.display = "block";
          } else {
            emptyRecipientsState.style.display = "flex";
            addRecipientBtnContainer.style.display = "none";
          }

          // Clear current list
          const listContainer = document.getElementById("recipientsList");

          // Remove all children except the empty state
          while (listContainer.firstChild) {
            if (listContainer.firstChild === emptyRecipientsState) {
              break;
            }
            listContainer.removeChild(listContainer.firstChild);
          }

          // Add recipients to the list
          recipients.forEach((recipient) => {
            const recipientElement = document.createElement("div");
            recipientElement.className = "recipient-item";
            recipientElement.dataset.id = recipient.id;

            const recipientInfo = document.createElement("div");
            recipientInfo.className = "recipient-info";

            const recipientLabel = document.createElement("div");
            recipientLabel.className = "recipient-label";
            recipientLabel.textContent = recipient.label;

            const recipientType = document.createElement("div");
            recipientType.className = "recipient-type";
            recipientType.textContent =
              recipient.type.charAt(0).toUpperCase() + recipient.type.slice(1);

            recipientInfo.appendChild(recipientLabel);
            recipientInfo.appendChild(recipientType);

            const recipientActions = document.createElement("div");
            recipientActions.className = "recipient-actions";

            const editBtn = document.createElement("button");
            editBtn.className = "action-btn edit-btn";
            editBtn.innerHTML = `
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
              </svg>
            `;
            editBtn.addEventListener("click", () =>
              showEditRecipientModal(recipient)
            );

            const deleteBtn = document.createElement("button");
            deleteBtn.className = "action-btn delete-btn";
            deleteBtn.innerHTML = `
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            `;
            deleteBtn.addEventListener("click", () =>
              deleteRecipient(recipient.id)
            );

            recipientActions.appendChild(editBtn);
            recipientActions.appendChild(deleteBtn);

            recipientElement.appendChild(recipientInfo);
            recipientElement.appendChild(recipientActions);

            // Insert before the empty state
            listContainer.insertBefore(recipientElement, emptyRecipientsState);
          });
        }

        function deleteRecipient(id) {
          if (confirm("Are you sure you want to delete this recipient?")) {
            // Remove recipient
            recipients = recipients.filter((r) => r.id !== id);
            hasRecipientsChanged = true;

            // Remove associated fields
            fields = fields.filter((f) => f.signerTypeId !== id);

            // Update display
            updateRecipientsDisplay();
            updateFieldsDisplay();
          }
        }

        // Field Management Functions
        function showFieldConfigModal() {
          fieldTypeSelect.value = selectedFieldType;
          fieldLabelInput.value = "";
          fieldRequiredCheckbox.checked = false;

          // Show/hide checkbox config based on field type
          const isCheckboxType = selectedFieldType === "checkbox_group";
          checkboxConfigDiv.style.display = isCheckboxType ? "block" : "none";

          if (isCheckboxType) {
            totalCheckboxesInput.value = "1";
            requiredCheckboxesInput.value = "0";
          }

          fieldConfigModal.classList.add("show");
        }

        function hideFieldConfigModal() {
          fieldConfigModal.classList.remove("show");

          // Remove the font size change listener
          const fontSizeInput = document.getElementById("fieldFontSize");
          const listenerName = fontSizeInput.getAttribute("data-listener");
          if (listenerName && window[listenerName]) {
            fontSizeInput.removeEventListener("change", window[listenerName]);
            delete window[listenerName];
            fontSizeInput.removeAttribute("data-listener");
          }

          activeField = null;
          lastClickPosition = null;
          isCreatingField = false;
          saveFieldBtn.textContent = "Create";
          deleteFieldBtn.style.display = "none";
        }

        function createField() {
          if (!selectedSignerTypeId) {
            alert("Please select a signer before adding fields.");
            hideFieldConfigModal();
            return;
          }

          const fieldType = fieldTypeSelect.value;
          const fieldLabel =
            fieldLabelInput.value.trim() ||
            fieldType.charAt(0).toUpperCase() + fieldType.slice(1);
          const required = fieldRequiredCheckbox.checked;
          const color = document.getElementById("fieldColor").value;
          const fontSize = parseInt(
            document.getElementById("fieldFontSize").value
          );
          const font = document.getElementById("fieldFont").value;
          const textLength = document.getElementById("textLength").value;

          // Find signer info
          const signer = recipients.find((r) => r.id === selectedSignerTypeId);
          if (!signer) {
            alert("Selected signer not found.");
            hideFieldConfigModal();
            return;
          }

          // Calculate height based on font size
          const lineHeight = fontSize * 1.1;
          const containerHeight =
            document.querySelector(".page-container").offsetHeight;
          const heightInPixels = lineHeight * 1.2;
          const heightPercentage = (heightInPixels / containerHeight) * 100;

          // If we're editing an existing field
          if (activeField) {
            // Update the existing field's properties
            activeField.type = fieldType;
            activeField.label = fieldLabel;
            activeField.required = required;
            activeField.color = color;
            activeField.fontSize = fontSize;
            activeField.font = font;
            if (fieldType === "text") {
              activeField.textLength = textLength;
            }

            // Update height for non-checkbox fields
            if (fieldType !== "checkbox_group") {
              activeField.height = heightPercentage;
            }

            // Update checkbox configuration if needed
            if (fieldType === "checkbox_group") {
              const totalCheckboxes = parseInt(totalCheckboxesInput.value) || 1;
              const requiredCheckboxes =
                parseInt(requiredCheckboxesInput.value) || 0;

              // Initialize or update checkbox group
              activeField.checkboxGroup = {
                options: Array(totalCheckboxes)
                  .fill()
                  .map((_, i) => {
                    // Preserve existing checkbox positions if they exist
                    const existingOption =
                      activeField.checkboxGroup?.options[i];
                    return {
                      label: existingOption?.label || `Option ${i + 1}`,
                      value: existingOption?.value || `option_${i + 1}`,
                      x: existingOption?.x || 0,
                      y: existingOption?.y || i * (100 / totalCheckboxes),
                      width: existingOption?.width || 24,
                      height: existingOption?.height || 24,
                    };
                  }),
                requiredSelections: requiredCheckboxes,
                maxSelections: totalCheckboxes,
              };
            }

            // Clear the active field reference
            activeField = null;
          } else {
            // Create a new field at the click position
            const newField = {
              type: fieldType,
              label: fieldLabel,
              required,
              color,
              fontSize,
              font,
              apiId: `field_${Date.now()}_${Math.random()
                .toString(36)
                .substr(2, 9)}`,
              x: lastClickPosition ? lastClickPosition.x : 10,
              y: lastClickPosition ? lastClickPosition.y : 10,
              width: getDefaultFieldWidth(fieldType, textLength),
              height: fieldType === "checkbox_group" ? 30 : heightPercentage,
              page: lastClickPosition
                ? lastClickPosition.page
                : currentPageNumber,
            };

            if (fieldType === "text") {
              newField.textLength = textLength;
            }

            // Add checkbox configuration if needed
            if (fieldType === "checkbox_group") {
              const totalCheckboxes = parseInt(totalCheckboxesInput.value) || 1;
              const requiredCheckboxes =
                parseInt(requiredCheckboxesInput.value) || 0;

              newField.checkboxGroup = {
                options: Array(totalCheckboxes)
                  .fill()
                  .map((_, i) => ({
                    label: `Option ${i + 1}`,
                    value: `option_${i + 1}`,
                    x: 0,
                    y: i * (100 / totalCheckboxes),
                    width: 24,
                    height: 24,
                  })),
                requiredSelections: requiredCheckboxes,
                maxSelections: totalCheckboxes,
              };
            }

            // Add field to the selected signer's fields array
            if (!signer.fields) {
              signer.fields = [];
            }
            signer.fields.push(newField);
          }

          // Clear the last click position
          lastClickPosition = null;

          hideFieldConfigModal();
          updateFieldsDisplay();
        }

        // Add helper functions for default field dimensions
        function getDefaultFieldWidth(fieldType, textLength = "medium") {
          switch (fieldType) {
            case "signature":
              return 30; // 30% of container width
            case "initials":
              return 15; // 15% of container width
            case "text":
              switch (textLength) {
                case "short":
                  return 15;
                case "medium":
                  return 25;
                case "long":
                  return 40;
                case "very_long":
                  return 60;
                default:
                  return 25;
              }
            case "date":
              return 20; // 20% of container width
            case "checkbox_group":
              return 30; // 30% of container width
            default:
              return 20; // Default width
          }
        }

        function getDefaultFieldHeight(fieldType, textLength = "medium") {
          const containerHeight =
            document.querySelector(".page-container").offsetHeight;
          const fontSize =
            parseInt(document.getElementById("fieldFontSize").value) || 12;
          const lineHeight = fontSize * 1.1; // Reduced from 1.2 to 1.1
          const heightInPixels = lineHeight * 1.2; // Reduced from 1.5 to 1.2
          const heightPercentage = (heightInPixels / containerHeight) * 100;

          switch (fieldType) {
            case "signature":
              return heightPercentage;
            case "initials":
              return heightPercentage * 0.8;
            case "text":
              return heightPercentage;
            case "date":
              return heightPercentage;
            case "checkbox_group":
              return 30;
            default:
              return heightPercentage;
          }
        }

        function deleteField(fieldId) {
          // Find the signer that owns this field
          const signer = recipients.find((r) => r.id === selectedSignerTypeId);
          if (signer && signer.fields) {
            // Remove the field from the signer's fields array
            signer.fields = signer.fields.filter((f) => f.id !== fieldId);
            updateFieldsDisplay();
          }
        }

        function updateFieldsDisplay() {
          // Find all fields layers
          const fieldsLayers = document.querySelectorAll(".fields-layer");

          // Clear all fields layers
          fieldsLayers.forEach((layer) => {
            layer.innerHTML = "";
          });

          // Find the selected signer
          const selectedSigner = recipients.find(
            (r) => r.id === selectedSignerTypeId
          );
          if (!selectedSigner) {
            console.log("No selected signer found");
            return;
          }

          // Get fields for the selected signer
          const signerFields = selectedSigner.fields || [];
          console.log("Updating display with fields:", signerFields);

          // Group fields by page
          const fieldsByPage = {};
          signerFields.forEach((field) => {
            if (!fieldsByPage[field.page]) {
              fieldsByPage[field.page] = [];
            }
            fieldsByPage[field.page].push(field);
          });

          // Render fields for each page
          fieldsLayers.forEach((layer, index) => {
            const pageNum = index + 1;
            const pageFields = fieldsByPage[pageNum] || [];
            renderFields(layer, pageFields);
          });
        }

        // Updated renderFields function to place labels inside the field containers
function renderFields(layer, fields) {
  fields.forEach((field) => {
    // Generate a unique ID for new fields if they don't have one
    if (!field.id) {
      field.id = `field_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
    }

    const fieldElement = document.createElement("div");
    fieldElement.className = "field";
    fieldElement.dataset.id = field.id;
    fieldElement.dataset.type = field.type;

    // Set field position and size
    fieldElement.style.left = `${field.x}%`;
    fieldElement.style.top = `${field.y}%`;
    fieldElement.style.width = `${field.width}%`;
    fieldElement.style.height = `${field.height}%`;

    // Apply styling properties
    fieldElement.style.color = field.color || "#334155";
    fieldElement.style.fontSize = `${field.fontSize || 12}px`;
    fieldElement.style.fontFamily = field.font || "Arial";

    // Add click handler for editing
    fieldElement.addEventListener("click", (e) => {
      if (!e.target.closest(".resize-handle")) {
        showEditFieldModal(field);
      }
    });

    // Create field content
    const fieldContent = document.createElement("div");
    fieldContent.className = "field-content";
    fieldContent.style.width = "100%";
    fieldContent.style.height = "100%";
    fieldContent.style.position = "relative";

    // Handle different field types
    if (field.type === "text") {
      const inputContainer = document.createElement("div");
      inputContainer.style.width = "100%";
      inputContainer.style.height = "100%";
      inputContainer.style.border = "1px solid #e2e8f0";
      inputContainer.style.borderRadius = "4px";
      inputContainer.style.backgroundColor = "#fdf47eb3";
      inputContainer.style.position = "relative";
      inputContainer.style.display = "flex";
      inputContainer.style.flexDirection = "column";

      // Label inside the container at the top
      const label = document.createElement("span");
      label.textContent = field.label;
      label.style.color = field.color || "#334155";
      label.style.fontSize = `${Math.max((field.fontSize || 12) * 0.8, 10)}px`;
      label.style.fontFamily = field.font || "Arial";
      label.style.fontWeight = "500";
      label.style.whiteSpace = "nowrap";
      label.style.overflow = "hidden";
      label.style.textOverflow = "ellipsis";
      
      if (field.required) {
        const requiredIndicator = document.createElement("span");
        requiredIndicator.textContent = " *";
        requiredIndicator.style.color = "#ef4444";
        label.appendChild(requiredIndicator);
      }

      // Placeholder container for the actual text content
      const placeholderContainer = document.createElement("div");
      placeholderContainer.style.flex = "1";
      placeholderContainer.style.display = "flex";
      placeholderContainer.style.alignItems = "center";

      // Placeholder text
      const placeholder = document.createElement("span");
      placeholder.style.color = "#94a3b8";
      placeholder.style.fontSize = `${field.fontSize || 12}px`;
      placeholder.style.fontFamily = field.font || "Arial";
      placeholder.style.fontStyle = "italic";
      
      // switch (field.textLength) {
      //   case "short":
      //     placeholder.textContent = "Short text...";
      //     break;
      //   case "medium":
      //     placeholder.textContent = "Medium length text...";
      //     break;
      //   case "long":
      //     placeholder.textContent = "Longer text...";
      //     break;
      //   case "very_long":
      //     placeholder.textContent = "Very long text...";
      //     break;
      //   default:
      //     placeholder.textContent = "Enter text...";
      // }

      placeholderContainer.appendChild(placeholder);
      inputContainer.appendChild(label);
      inputContainer.appendChild(placeholderContainer);
      fieldContent.appendChild(inputContainer);

    } else if (field.type === "checkbox_group" && field.checkboxGroup) {
      const checkboxContainer = document.createElement("div");
      checkboxContainer.className = "checkbox-container";
      checkboxContainer.style.position = "relative";
      checkboxContainer.style.height = "100%";
      checkboxContainer.style.width = "100%";
      checkboxContainer.style.display = "flex";
      checkboxContainer.style.flexDirection = "column";
      checkboxContainer.style.gap = "8px";
      checkboxContainer.style.padding = "8px";
      checkboxContainer.style.border = "1px solid #e2e8f0";
      checkboxContainer.style.borderRadius = "4px";
      checkboxContainer.style.backgroundColor = "rgba(255, 255, 255, 0.9)";

      // Add label inside the checkbox container
      const label = document.createElement("div");
      label.textContent = field.label;
      label.style.color = field.color || "#000000";
      label.style.fontSize = `${Math.max((field.fontSize || 12) * 0.8, 10)}px`;
      label.style.fontFamily = field.font || "Arial";
      label.style.fontWeight = "500";
      label.style.marginBottom = "4px";
      label.style.whiteSpace = "nowrap";
      label.style.overflow = "hidden";
      label.style.textOverflow = "ellipsis";
      
      if (field.required) {
        const requiredIndicator = document.createElement("span");
        requiredIndicator.textContent = " *";
        requiredIndicator.style.color = "#ef4444";
        label.appendChild(requiredIndicator);
      }

      checkboxContainer.appendChild(label);

      field.checkboxGroup.options.forEach((option, index) => {
        const checkboxWrapper = document.createElement("div");
        checkboxWrapper.className = "checkbox-wrapper";
        checkboxWrapper.style.position = "absolute";
        checkboxWrapper.style.left = `${option.x || 0}%`;
        checkboxWrapper.style.height = `${option.height || 24}px`;
        checkboxWrapper.style.width = `${option.width || 24}px`;
        checkboxWrapper.style.display = "flex";
        checkboxWrapper.style.alignItems = "center";
        checkboxWrapper.style.justifyContent = "center";
        checkboxWrapper.style.cursor = "move";

        const yPosition = option.y || index * (100 / field.checkboxGroup.options.length);
        checkboxWrapper.style.top = `${yPosition + 20}%`; // Offset for the label

        const checkbox = document.createElement("div");
        checkbox.className = "field-checkbox";
        checkbox.style.width = "100%";
        checkbox.style.height = "100%";
        checkbox.style.border = "1px solid #94a3b8";
        checkbox.style.borderRadius = "4px";
        checkbox.style.backgroundColor = "white";
        checkbox.style.cursor = "pointer";

        // Add resize handle for the checkbox
        const resizeHandle = document.createElement("div");
        resizeHandle.className = "resize-handle";
        resizeHandle.style.position = "absolute";
        resizeHandle.style.bottom = "-5px";
        resizeHandle.style.right = "-5px";
        resizeHandle.style.width = "8px";
        resizeHandle.style.height = "8px";
        resizeHandle.style.backgroundColor = "#2563eb";
        resizeHandle.style.borderRadius = "50%";
        resizeHandle.style.cursor = "nwse-resize";

        // Add resize functionality
        resizeHandle.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          handleCheckboxResizeStart(e, checkboxWrapper, field, index);
        });

        // Add drag functionality
        checkboxWrapper.addEventListener("mousedown", (e) => {
          if (!e.target.closest(".resize-handle")) {
            e.stopPropagation();
            handleCheckboxDragStart(e, checkboxWrapper, field, index);
          }
        });

        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(resizeHandle);
        checkboxContainer.appendChild(checkboxWrapper);
      });

      fieldContent.appendChild(checkboxContainer);

    } else {
      // For signature, initials, and date fields
      const inputContainer = document.createElement("div");
      inputContainer.style.width = "100%";
      inputContainer.style.height = "100%";
      inputContainer.style.position = "relative";
      inputContainer.style.borderRadius = "4px";
      inputContainer.style.backgroundColor = "#fdf47eb3";
      inputContainer.style.display = "flex";
      inputContainer.style.flexDirection = "column";
      inputContainer.style.justifyContent = "center";

      // Label inside the container
      const label = document.createElement("span");
      label.textContent = field.label || field.type.charAt(0).toUpperCase() + field.type.slice(1);
      label.style.color = field.color || "#000000";
      label.style.fontSize = `${Math.max((field.fontSize || 12) * 0.8, 10)}px`;
      label.style.fontFamily = field.font || "Arial";
      label.style.fontWeight = "500";
      label.style.textAlign = "center";
      label.style.whiteSpace = "nowrap";
      label.style.overflow = "hidden";
      label.style.textOverflow = "ellipsis";

      // Add a visual indicator for required fields
      if (field.required) {
        const requiredIndicator = document.createElement("span");
        requiredIndicator.textContent = " *";
        requiredIndicator.style.color = "#ef4444";
        label.appendChild(requiredIndicator);
      }

      inputContainer.appendChild(label);
      fieldContent.appendChild(inputContainer);
    }

    // Add resize handle (keep this outside the field content)
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "resize-handle";
    resizeHandle.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      handleResizeStart(e, field);
    });

    // Add mouse down handler for dragging
    fieldElement.addEventListener("mousedown", (e) => {
      handleFieldMouseDown(e, field);
    });

    // Assemble field element
    fieldElement.appendChild(fieldContent);
    fieldElement.appendChild(resizeHandle);

    // Add to layer
    layer.appendChild(fieldElement);
  });
}

        function handleFieldMouseDown(e, field) {
          e.preventDefault();
          e.stopPropagation();

          isDragging = true;
          activeField = field;

          const pageContainers = document.querySelectorAll(".page-container");
          const targetPage = pageContainers[field.page - 1];
          if (!targetPage) return;

          const containerRect = targetPage.getBoundingClientRect();
          const pageOffsetX = containerRect.left;
          const pageOffsetY = containerRect.top;

          initialMousePos = {
            x: e.clientX - pageOffsetX,
            y: e.clientY - pageOffsetY,
          };

          initialFieldPos = {
            x: field.x,
            y: field.y,
          };

          document.addEventListener("mousemove", handleDrag);
          document.addEventListener("mouseup", handleDragEnd);
        }

        function handleDrag(e) {
          if (!isDragging || !activeField) return;

          const pageContainers = document.querySelectorAll(".page-container");
          const targetPage = pageContainers[activeField.page - 1];
          if (!targetPage) return;

          const containerRect = targetPage.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;

          // Calculate delta
          const deltaX = mouseX - initialMousePos.x;
          const deltaY = mouseY - initialMousePos.y;

          // Update field position
          const newX = initialFieldPos.x + (deltaX / containerRect.width) * 100;
          const newY =
            initialFieldPos.y + (deltaY / containerRect.height) * 100;

          // Ensure field stays within bounds
          activeField.x = Math.max(0, Math.min(100 - activeField.width, newX));
          activeField.y = Math.max(0, Math.min(100 - activeField.height, newY));

          // Update display
          updateFieldsDisplay();
        }

        function handleDragEnd() {
          isDragging = false;
          activeField = null;
          document.removeEventListener("mousemove", handleDrag);
          document.removeEventListener("mouseup", handleDragEnd);
        }

        function handleResizeStart(e, field) {
          e.preventDefault();
          e.stopPropagation();

          isResizing = true;
          activeField = field;

          const pageContainers = document.querySelectorAll(".page-container");
          const targetPage = pageContainers[field.page - 1];
          if (!targetPage) return;

          const containerRect = targetPage.getBoundingClientRect();
          const pageOffsetX = containerRect.left;
          const pageOffsetY = containerRect.top;

          initialMousePos = {
            x: e.clientX - pageOffsetX,
            y: e.clientY - pageOffsetY,
          };

          initialFieldSize = {
            width: field.width,
            height: field.height,
          };

          document.addEventListener("mousemove", handleResize);
          document.addEventListener("mouseup", handleResizeEnd);
        }

        function handleResize(e) {
          if (!isResizing || !activeField) return;

          const pageContainers = document.querySelectorAll(".page-container");
          const targetPage = pageContainers[activeField.page - 1];
          if (!targetPage) return;

          const containerRect = targetPage.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;

          // Calculate delta
          const deltaX = mouseX - initialMousePos.x;
          const deltaY = mouseY - initialMousePos.y;

          // Update field size
          const newWidth = Math.max(
            1,
            initialFieldSize.width + (deltaX / containerRect.width) * 100
          );
          const newHeight = Math.max(
            1,
            initialFieldSize.height + (deltaY / containerRect.height) * 100
          );

          // Ensure field stays within bounds
          activeField.width = Math.min(100 - activeField.x, newWidth);
          activeField.height = Math.min(100 - activeField.y, newHeight);

          // Update display
          updateFieldsDisplay();
        }

        function handleResizeEnd() {
          isResizing = false;
          activeField = null;
          document.removeEventListener("mousemove", handleResize);
          document.removeEventListener("mouseup", handleResizeEnd);
        }

        // Document Loading and Saving Functions
        async function loadDocument() {
          console.log("Loading document with URL:", documentUrl);
          if (!documentUrl) {
            alert("No document URL provided");
            return;
          }

          // Show a loading indicator
          documentViewer.innerHTML =
            '<div style="display:flex;justify-content:center;align-items:center;height:200px;"><p>Loading document...</p></div>';

          try {
            // Load the PDF document
            const loadingTask = pdfjsLib.getDocument(documentUrl);
            currentPdf = await loadingTask.promise;
            console.log(
              "PDF loaded successfully with",
              currentPdf.numPages,
              "pages"
            );

            // Clear previous content
            documentViewer.innerHTML = "";

            // Create a container for all pages
            const pagesContainer = document.createElement("div");
            pagesContainer.className = "pages-container";
            documentViewer.appendChild(pagesContainer);

            // Render all pages
            for (let i = 1; i <= currentPdf.numPages; i++) {
              const pageContainer = document.createElement("div");
              pageContainer.className = "page-container";
              pageContainer.style.position = "relative";
              pageContainer.style.marginBottom = "20px";
              pageContainer.dataset.page = i;

              const canvas = document.createElement("canvas");
              pageContainer.appendChild(canvas);
              pagesContainer.appendChild(pageContainer);

              const page = await currentPdf.getPage(i);

              // Get the original viewport dimensions
              const originalViewport = page.getViewport({ scale: 1.0 });

              // Calculate a suitable scale to fit within the viewer
              // while maintaining aspect ratio
              const containerWidth = documentViewer.clientWidth - 40; // Account for padding
              const scale = containerWidth / originalViewport.width;

              // Create viewport with calculated scale
              const viewport = page.getViewport({ scale: scale });

              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              // Set container dimensions to match canvas
              pageContainer.style.width = `${viewport.width}px`;
              pageContainer.style.height = `${viewport.height}px`;

              // Store the scale for later use in field positioning
              pageContainer.dataset.scale = scale;

              // Render PDF page
              await page.render({
                canvasContext: context,
                viewport: viewport,
              }).promise;

              // Create fields layer for this page with matching dimensions
              const fieldsLayer = document.createElement("div");
              fieldsLayer.className = "fields-layer";
              fieldsLayer.style.position = "absolute";
              fieldsLayer.style.top = "0";
              fieldsLayer.style.left = "0";
              fieldsLayer.style.width = `${viewport.width}px`;
              fieldsLayer.style.height = `${viewport.height}px`;
              fieldsLayer.dataset.originalWidth = originalViewport.width;
              fieldsLayer.dataset.originalHeight = originalViewport.height;
              pageContainer.appendChild(fieldsLayer);
            }

            // After loading the PDF, populate the page selector
            if (pageSelector && currentPdf) {
              pageSelector.innerHTML = ""; // Clear existing options
              for (let i = 1; i <= currentPdf.numPages; i++) {
                const option = document.createElement("option");
                option.value = i;
                option.textContent = `Page ${i}`;
                pageSelector.appendChild(option);
              }
              pageSelector.value = currentPageNumber; // Set initial page
            }

            // Add event listener for page selector
            pageSelector.addEventListener("change", (e) => {
              const pageNum = parseInt(e.target.value);
              if (pageNum && pageNum <= currentPdf.numPages) {
                currentPageNumber = pageNum;

                // Scroll to the selected page
                const pageElements =
                  document.querySelectorAll(".page-container");
                if (pageElements[pageNum - 1]) {
                  pageElements[pageNum - 1].scrollIntoView({
                    behavior: "smooth",
                  });
                }
              }
            });

            // Add click handlers to the document viewer for adding fields
            documentViewer.addEventListener("click", (e) => {
              // Only handle clicks directly on the page container or canvas
              const pageContainer = e.target.closest(".page-container");
              if (!pageContainer || e.target.closest(".field")) return;

              // Update current page number
              const pageIndex = Array.from(
                document.querySelectorAll(".page-container")
              ).indexOf(pageContainer);
              if (pageIndex !== -1) {
                currentPageNumber = pageIndex + 1;
                if (pageSelector) {
                  pageSelector.value = currentPageNumber;
                }
              }

              // If we're in field creation mode, get the click position and show the modal
              if (isCreatingField) {
                // Get the click position relative to the page container
                const containerRect = pageContainer.getBoundingClientRect();
                const clickX = e.clientX - containerRect.left;
                const clickY = e.clientY - containerRect.top;

                // Convert click position to percentages
                const xPercent = (clickX / containerRect.width) * 100;
                const yPercent = (clickY / containerRect.height) * 100;

                // Store the click position for field creation
                lastClickPosition = {
                  x: xPercent,
                  y: yPercent,
                  page: currentPageNumber,
                };

                // Show the field configuration modal
                showFieldConfigModal();
                // Reset the creation mode
                isCreatingField = false;
              }
            });

            // Update fields display
            updateFieldsDisplay();

            // If we have recipients, update the signer selector
            if (recipients.length > 0) {
              updateSignerSelector();
            }
          } catch (error) {
            console.error("Error loading document:", error);
            console.error("Error stack:", error.stack);
            alert("Failed to load document: " + error.message);
          }
        }

        async function saveTemplate() {
          if (!templateId) {
            alert("No template ID provided");
            return;
          }

          try {
            // First, save signer types with their fields
            const signerTypes = recipients.map((recipient, index) => {
              const fields = (recipient.fields || []).map((field) => ({
                type: field.type,
                label: field.label || "",
                required: field.required || false,
                x: field.x,
                y: field.y,
                width: field.width,
                height: field.height,
                page: field.page,
                apiId:
                  field.apiId ||
                  `field_${Date.now()}_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`,
                color: field.color || "#000000",
                fontSize: field.fontSize || 12,
                font: field.font || "Arial",
                checkboxGroup:
                  field.type === "checkbox_group" && field.checkboxGroup
                    ? {
                        options: field.checkboxGroup.options.map((opt) => ({
                          label: opt.label,
                          value: opt.value,
                          x: opt.x || 0,
                          y: opt.y || 0,
                          width: opt.width || 24, // Include width
                          height: opt.height || 24, // Include height
                        })),
                        requiredSelections:
                          field.checkboxGroup.requiredSelections,
                        maxSelections: field.checkboxGroup.maxSelections,
                      }
                    : undefined,
              }));

              if (recipient.id && recipient.id.includes("_")) {
                return {
                  _id: recipient.id,
                  type: recipient.type,
                  label: recipient.label,
                  order: index + 1,
                  fields: fields,
                };
              } else {
                return {
                  type: recipient.type,
                  label: recipient.label,
                  order: index + 1,
                  fields: fields,
                };
              }
            });

            console.log("Saving signer types with fields:", signerTypes);

            const signersResponse = await fetch(`${API_URL}/templates/signer-types`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${localStorage.getItem("token")}`,
              },
              body: JSON.stringify({
                templateId,
                signerTypes,
              }),
            });

            if (!signersResponse.ok) {
              const errorData = await signersResponse.json();
              throw new Error(
                errorData.message || "Failed to save signer types"
              );
            }

            const signersData = await signersResponse.json();

            if (!signersData.success) {
              throw new Error(
                signersData.message || "Failed to save signer types"
              );
            }

            // Redirect to success page
            window.location.href = `/template-create/success/${templateId}`;
          } catch (error) {
            console.error("Error saving template:", error);
            alert("Error saving template: " + error.message);
          }
        }

        // Initialize the page
        goToStep(1);

        // Add checkbox drag handling functions
        function handleCheckboxDragStart(e, checkboxWrapper, field, index) {
          e.preventDefault();
          isCheckboxDragging = true;
          activeCheckbox = checkboxWrapper;
          activeCheckboxField = field;
          activeCheckboxIndex = index;

          const containerRect =
            checkboxWrapper.parentElement.getBoundingClientRect();
          initialMousePos = {
            x: e.clientX - containerRect.left,
            y: e.clientY - containerRect.top,
          };

          // Store initial position as percentages
          initialFieldPos = {
            x: parseFloat(checkboxWrapper.style.left) || 0,
            y: parseFloat(checkboxWrapper.style.top) || 0,
          };

          document.addEventListener("mousemove", handleCheckboxDrag);
          document.addEventListener("mouseup", handleCheckboxDragEnd);
        }

        function handleCheckboxDrag(e) {
          if (!isCheckboxDragging || !activeCheckbox || !activeCheckboxField)
            return;

          const containerRect =
            activeCheckbox.parentElement.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;

          // Calculate new position as percentages
          const deltaX = mouseX - initialMousePos.x;
          const deltaY = mouseY - initialMousePos.y;

          // Convert pixel deltas to percentages
          const newX = initialFieldPos.x + (deltaX / containerRect.width) * 100;
          const newY =
            initialFieldPos.y + (deltaY / containerRect.height) * 100;

          // Ensure checkbox stays within container bounds
          const maxX =
            100 - (activeCheckbox.offsetWidth / containerRect.width) * 100;
          const maxY =
            100 - (activeCheckbox.offsetHeight / containerRect.height) * 100;

          // Update checkbox position
          activeCheckbox.style.left = `${Math.max(0, Math.min(maxX, newX))}%`;
          activeCheckbox.style.top = `${Math.max(0, Math.min(maxY, newY))}%`;

          // Update the field's checkbox data
          if (
            activeCheckboxField.checkboxGroup &&
            activeCheckboxField.checkboxGroup.options[activeCheckboxIndex]
          ) {
            activeCheckboxField.checkboxGroup.options[activeCheckboxIndex].x =
              Math.max(0, Math.min(maxX, newX));
            activeCheckboxField.checkboxGroup.options[activeCheckboxIndex].y =
              Math.max(0, Math.min(maxY, newY));
          }
        }

        function handleCheckboxDragEnd() {
          isCheckboxDragging = false;
          activeCheckbox = null;
          activeCheckboxField = null;
          activeCheckboxIndex = null;
          document.removeEventListener("mousemove", handleCheckboxDrag);
          document.removeEventListener("mouseup", handleCheckboxDragEnd);
        }

        // Add this new function after the renderFields function
        function showEditFieldModal(field) {
          // Set the field type
          fieldTypeSelect.value = field.type;

          // Set the field label
          fieldLabelInput.value = field.label || "";

          // Set required checkbox
          fieldRequiredCheckbox.checked = field.required || false;

          // Set styling properties
          document.getElementById("fieldColor").value =
            field.color || "#000000";
          document.getElementById("fieldFontSize").value = field.fontSize || 12;
          document.getElementById("fieldFont").value = field.font || "Arial";

          // Remove any existing font size change listeners
          const fontSizeInput = document.getElementById("fieldFontSize");
          const oldListener = fontSizeInput.getAttribute("data-listener");
          if (oldListener) {
            fontSizeInput.removeEventListener("change", window[oldListener]);
          }

          // Create a unique listener name for this field
          const listenerName = `fontSizeListener_${field.id}`;

          // Create and store the listener function
          window[listenerName] = function () {
            const newFontSize = parseInt(fontSizeInput.value) || 12;
            const lineHeight = newFontSize * 1.1;
            const containerHeight =
              document.querySelector(".page-container").offsetHeight;
            const heightInPixels = lineHeight * 1.2;
            const heightPercentage = (heightInPixels / containerHeight) * 100;

            // Only update the current field's height
            if (field.type !== "checkbox_group") {
              field.height = heightPercentage;
              // Update the display immediately
              const fieldElement = document.querySelector(
                `[data-id="${field.id}"]`
              );
              if (fieldElement) {
                fieldElement.style.height = `${heightPercentage}%`;
              }
            }
          };

          // Add the new listener
          fontSizeInput.addEventListener("change", window[listenerName]);

          // Store the listener name for later removal
          fontSizeInput.setAttribute("data-listener", listenerName);

          // Show/hide config sections based on field type
          const isCheckboxType = field.type === "checkbox_group";
          const isTextType = field.type === "text";
          checkboxConfigDiv.style.display = isCheckboxType ? "block" : "none";
          textLengthConfig.style.display = isTextType ? "block" : "none";

          if (isCheckboxType && field.checkboxGroup) {
            totalCheckboxesInput.value = field.checkboxGroup.options.length;
            requiredCheckboxesInput.value =
              field.checkboxGroup.requiredSelections || 0;
          }

          if (isTextType) {
            document.getElementById("textLength").value =
              field.textLength || "medium";
          }

          // Store the field being edited
          activeField = field;

          // Show the modal
          fieldConfigModal.classList.add("show");

          // Update the save button text and show delete button
          saveFieldBtn.textContent = "Save Changes";
          deleteFieldBtn.style.display = "block";
        }

        // Update the saveField function to handle font size changes
        function saveField() {
          if (!activeField) return;

          // Get the new font size
          const newFontSize =
            parseInt(document.getElementById("fieldFontSize").value) || 12;

          // Calculate new height based on font size
          const lineHeight = newFontSize * 1.1; // Reduced from 1.2 to 1.1
          const containerHeight =
            document.querySelector(".page-container").offsetHeight;
          const heightInPixels = lineHeight * 1.2; // Reduced from 1.5 to 1.2
          const heightPercentage = (heightInPixels / containerHeight) * 100;

          // Update field properties
          activeField.fontSize = newFontSize;
          activeField.font = document.getElementById("fieldFont").value;
          activeField.color = document.getElementById("fieldColor").value;
          activeField.label = document.getElementById("fieldLabel").value;
          activeField.required =
            document.getElementById("fieldRequired").checked;

          // Update height for non-checkbox fields
          if (activeField.type !== "checkbox_group") {
            activeField.height = heightPercentage;
          }

          // Update the display
          updateFieldsDisplay();

          // Hide the modal
          hideFieldConfigModal();
        }

        // Update the delete field button handler
        const deleteFieldBtn = document.getElementById("deleteField");
        deleteFieldBtn.addEventListener("click", () => {
          if (activeField) {
            if (confirm("Are you sure you want to delete this field?")) {
              // Find the signer that owns this field
              const signer = recipients.find(
                (r) => r.id === selectedSignerTypeId
              );
              if (signer && signer.fields) {
                // Remove the field from the signer's fields array
                signer.fields = signer.fields.filter((f) => {
                  // For new fields that don't have an ID yet, compare all properties
                  if (!f.id && !activeField.id) {
                    return !(
                      f.type === activeField.type &&
                      f.label === activeField.label &&
                      f.x === activeField.x &&
                      f.y === activeField.y &&
                      f.page === activeField.page
                    );
                  }
                  // For existing fields, compare by ID
                  return f.id !== activeField.id;
                });

                // Clear the active field reference
                activeField = null;

                // Update the display
                updateFieldsDisplay();

                // Hide the modal
                hideFieldConfigModal();
              }
            }
          }
        });

        // Add these new functions for checkbox resizing
        function handleCheckboxResizeStart(e, checkboxWrapper, field, index) {
          e.preventDefault();
          isResizing = true;
          activeField = field;
          activeCheckboxIndex = index;

          const containerRect =
            checkboxWrapper.parentElement.getBoundingClientRect();
          initialMousePos = {
            x: e.clientX - containerRect.left,
            y: e.clientY - containerRect.top,
          };

          // Store initial position as percentages
          initialFieldPos = {
            x: parseFloat(checkboxWrapper.style.left) || 0,
            y: parseFloat(checkboxWrapper.style.top) || 0,
          };

          document.addEventListener("mousemove", handleCheckboxResize);
          document.addEventListener("mouseup", handleCheckboxResizeEnd);
        }

        function handleCheckboxResize(e) {
          if (!isResizing || !activeField || activeCheckboxIndex === null)
            return;

          const containerRect = document
            .querySelector(".checkbox-container")
            .getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;

          // Calculate new size
          const newWidth = Math.max(
            16,
            initialFieldSize.width + (mouseX - initialMousePos.x)
          );
          const newHeight = Math.max(
            16,
            initialFieldSize.height + (mouseY - initialMousePos.y)
          );

          // Update checkbox size
          const checkboxWrapper = document.querySelector(
            `.checkbox-wrapper:nth-child(${activeCheckboxIndex + 1})`
          );
          if (checkboxWrapper) {
            checkboxWrapper.style.width = `${newWidth}px`;
            checkboxWrapper.style.height = `${newHeight}px`;
          }

          // Update the field's checkbox data
          if (
            activeField.checkboxGroup &&
            activeField.checkboxGroup.options[activeCheckboxIndex]
          ) {
            activeField.checkboxGroup.options[activeCheckboxIndex].width =
              newWidth;
            activeField.checkboxGroup.options[activeCheckboxIndex].height =
              newHeight;
          }
        }

        function handleCheckboxResizeEnd() {
          isResizing = false;
          activeField = null;
          activeCheckboxIndex = null;
          document.removeEventListener("mousemove", handleCheckboxResize);
          document.removeEventListener("mouseup", handleCheckboxResizeEnd);
        }
      });
    </script>
  </body>
</html>
