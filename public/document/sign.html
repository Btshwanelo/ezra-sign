<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sign Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>
    <style>
      /* Base styles */
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f8fafc; /* slate-50 */
        color: #334155; /* slate-700 */
        overflow-x: hidden;
      }

      /* Improve PDF rendering quality */
      .pdf-viewer canvas {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;
        transform: translateZ(0);
        backface-visibility: hidden;
        perspective: 1000;
        will-change: transform;
      }

      /* Ensure PDF pages are rendered at high quality */
      .pdf-viewer > div {
        transform-origin: 0 0;
        transform: scale(1);
        will-change: transform;
      }

      /* Loading overlay styles */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .loading-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid #e2e8f0;
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
      }

      .loading-text {
        color: #1e293b;
        font-size: 1rem;
        font-weight: 500;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Navbar styles */
      .navbar {
        background-color: white;
        padding: 1rem 2rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .navbar-content {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
      }

      .navbar-title {
        font-size: 0.9rem;
        font-weight: 500;
        color: #1e293b;
        flex: 1;
        text-align: left;
      }

      .navbar-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        width: 160px;
      }

      /* Add styles for navbar notifications */
      .navbar.notification {
        transition: background-color 0.3s ease;
      }

      .navbar.notification.error {
        background-color: #fee2e2;
      }

      .navbar.notification.success {
        background-color: #dcfce7;
      }

      .navbar.notification .navbar-content {
        justify-content: center;
      }

      .navbar.notification .navbar-title {
        color: inherit;
        text-align: center;
      }

      .navbar.notification.error .navbar-title {
        color: #dc2626;
      }

      .navbar.notification.success .navbar-title {
        color: #16a34a;
      }

      .navbar.notification .navbar-actions {
        display: none;
      }

      .logo {
        height: 40px;
        width: auto;
      }

      .container {
        width: 90%;
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        overflow-x: hidden;
        margin-top: 1rem; /* Add some space for notifications */
      }

      .document-title {
        font-size: 1.25rem;
        margin-bottom: 1.5rem;
        color: #1e293b; /* slate-800 */
        font-weight: 500;
        display: none;
      }

      .pdf-container {
        position: relative;
        width: fit-content;
        margin: 0 auto;
        overflow: hidden;
        max-width: 100%;
        display: flex;
        justify-content: center;
        background-color: #f8fafc; /* slate-50 */
      }

      .pdf-viewer {
        width: 100%;
        max-width: 100%;
        background-color: #f8fafc; /* slate-50 */
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 1rem;
      }

      /* Ensure PDF pages are responsive */
      .pdf-viewer > div {
        width: 100%;
        max-width: 100%;
        margin: 0 auto;
        position: relative;
        display: flex;
        justify-content: center;
      }

      .pdf-viewer canvas {
        max-width: 100%;
        height: auto;
        display: block;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .navbar {
          padding: 0.75rem 1rem;
        }

        .logo {
          height: 30px;
        }

        .container {
          padding: 1rem;
        }

        .pdf-container {
          margin: 0;
        }

        /* Adjust field sizes for mobile */
        .field {
          border-width: 1px;
        }

        .field-label {
          font-size: 0.65rem;
          top: -15px;
          display: none;
        }

        .field-input {
          font-size: 0.75rem;
          padding: 0.25rem;
        }
      }

      /* Field styles */
      .field {
        position: absolute;
        background-color: #fdf47eb3;
        cursor: pointer;
        border-radius: 0.3rem;
        transition: background-color 0.2s;
        transform-origin: top left;
        max-width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }

      .field:hover {
        background-color: rgba(37, 99, 235, 0.1); /* blue-600 with opacity */
      }

      .field-label {
        position: absolute;
        top: -20px;
        left: 0;
        color: #2563eb; /* blue-600 */
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        background-color: white;
        padding: 0 4px;
        display: none;
      }

      .field-input {
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
        /* padding: 0.375rem; */
        box-sizing: border-box;
        color: #334155; /* slate-700 */
        font-family: inherit;
        resize: none;
        overflow: hidden;
        line-height: 1.2;
        display: flex;
        align-items: center;
        justify-content: flex-start;
      }

      .field-input:focus {
        outline: none;
        background-color: rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1); /* blue-600 with opacity */
      }

      /* Button styles */
      .btn-primary {
        padding: 0.625rem 1.25rem;
        background: #2563eb; /* blue-600 */
        color: white;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .btn-primary:hover {
        background: #1d4ed8; /* blue-700 */
      }

      .btn-primary:disabled {
        background-color: #cbd5e1; /* slate-300 */
        cursor: not-allowed;
      }

      /* Message styles */
      .message-container {
        position: fixed;
        top: 4.5rem; /* Position below navbar */
        left: 0;
        right: 0;
        width: 100%;
        z-index: 1000;
        pointer-events: none;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0 1rem;
      }

      #criticalMessage {
        top: 8rem; /* Position below regular messages */
      }

      .error-message {
        color: #dc2626; /* red-600 */
        padding: 1rem 2rem;
        background-color: rgba(254, 226, 226, 0.95); /* red-100 with opacity */
        border-left: 4px solid #dc2626; /* red-600 */
        border-radius: 0.375rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        animation: slideDown 0.3s ease-out;
        pointer-events: auto;
        position: relative;
        backdrop-filter: blur(8px);
        width: 100%;
        max-width: 600px;
        text-align: center;
        margin: 0 auto;
      }

      .success-message {
        color: #16a34a; /* green-600 */
        padding: 1rem 2rem;
        background-color: rgba(
          220,
          252,
          231,
          0.95
        ); /* green-100 with opacity */
        border-left: 4px solid #16a34a; /* green-600 */
        border-radius: 0.375rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        animation: slideDown 0.3s ease-out;
        pointer-events: auto;
        position: relative;
        backdrop-filter: blur(8px);
        width: 100%;
        max-width: 600px;
        text-align: center;
        margin: 0 auto;
      }

      @keyframes slideDown {
        from {
          transform: translateY(-100%);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* Signature Modal Styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(15, 23, 42, 0.5); /* slate-900 with opacity */
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .modal.show {
        display: flex !important;
        align-items: center;
        justify-content: center;
        opacity: 1;
      }

      .modal-content {
        background-color: white;
        padding: 1.5rem;
        width: 80%;
        max-width: 600px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        position: relative;
        border-radius: 0rem;
      }

      .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        width: 2rem;
        height: 2rem;
        border-radius: 0.375rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #64748b; /* slate-500 */
        transition: all 0.2s;
        border: none;
        background: transparent;
        padding: 0;
      }

      .modal-close:hover {
        background-color: #f1f5f9; /* slate-100 */
        color: #334155; /* slate-700 */
      }

      .modal-close svg {
        width: 1.5rem;
        height: 1.5rem;
      }

      .modal-title {
        margin-top: 0;
        margin-bottom: 1.25rem;
        color: #1e293b; /* slate-800 */
        font-size: 1.25rem;
        font-weight: 600;
        padding-right: 2rem;
      }

      .signature-canvas-container {
        margin: 1.25rem 0;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem;
        overflow: hidden;
        width: 100%;
        height: 200px;
      }

      #signatureCanvas {
        background-color: white;
        cursor: crosshair;
        width: 100%;
        height: 100%;
        display: block;
      }

      .signature-controls {
        display: flex;
        gap: 0.625rem;
        margin-top: 1.25rem;
        justify-content: center;
        align-items: center;
      }

      .btn-clear {
        padding: 0.5rem 1rem;

        background: transparent;
        position: absolute;
        top: 1rem;
        right: 3rem;
        color: #64748b; /* slate-500 */
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        text-decoration: underline;
      }

      .btn-clear:hover {
        color: #334155; /* slate-700 */
      }

      .btn-save {
        padding: 0.825rem 2.25rem;
        background: #2563eb; /* blue-600 */
        color: white;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 120px;
      }

      .btn-save:hover {
        background: #1d4ed8; /* blue-700 */
      }

      .btn-save:disabled {
        background-color: #cbd5e1; /* slate-300 */
        cursor: not-allowed;
      }

      .field.signature-field {
        background-color: transparent;
        /* border: 1px solid #fdf47eb3; */
        background-color: #fdf47eb3;
      }

      .field.signature-field .signature-preview {
        width: 100%;
        height: 100%;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #64748b; /* slate-500 */
        font-size: 0.75rem;
        text-align: center;
        padding: 0.5rem;
        box-sizing: border-box;
        word-break: break-word;
        overflow: hidden;
      }

      /* Checkbox Group Styles */
      .field.checkbox-group-field {
        background-color: transparent;
        padding: 0;
        display: flex;
        flex-direction: column;
        position: absolute;
      }

      .checkbox-group-container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      .checkbox-option {
        position: absolute;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        transform-origin: top left;
        width: 100%;
        height: 100%;
      }

      .checkbox-option input[type="checkbox"] {
        width: 100%;
        height: 100%;
        cursor: pointer;
        margin: 0;
        padding: 0;
        border: none;
        appearance: none;
        -webkit-appearance: none;
        background-color: #fdf47eb3;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
      }

      .checkbox-option input[type="checkbox"]:checked {
        background-color: #2563eb;
        position: relative;
      }

      .checkbox-option input[type="checkbox"]:checked::after {
        content: "âœ“";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 1rem;
      }

      .checkbox-option label {
        font-size: 0.75rem;
        color: #334155;
        cursor: pointer;
        margin: 0;
        white-space: nowrap;
        display: none;
      }

      /* Add styles for the already signed notification */
      .already-signed-notification {
        background-color: #dcfce7; /* amber-100 */
        border-left: 4px solid #16a34a; /* amber-600 */
        color: #16a34a; /* amber-800 */
        padding: 1rem;
        margin-bottom: 2rem;
        border-radius: 0.375rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        position: fixed;
        top: 5rem; /* Position below navbar */
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 10rem);
        max-width: 1150px;
        z-index: 1000;
        backdrop-filter: blur(8px);
        background-color: rgba(
          220,
          252,
          231,
          0.95
        ); /* green-100 with opacity */
      }

      .already-signed-notification svg {
        width: 1.5rem;
        height: 1.5rem;
        flex-shrink: 0;
      }

      /* Add styles for the navigation buttons */
      .navigation-buttons {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: center;
        z-index: 1000;
      }

      .action-button {
        padding: 0.75rem 2rem;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        min-width: 160px;
        justify-content: center;
      }

      .action-button:hover {
        background: #1d4ed8;
      }

      .action-button:disabled {
        background-color: #cbd5e1;
        cursor: not-allowed;
      }

      .action-button svg {
        width: 1.25rem;
        height: 1.25rem;
      }

      .action-button.start {
        background: #2563eb;
      }

      .action-button.next {
        background: #2563eb;
      }

      .action-button.complete {
        background: #16a34a;
      }

      .action-button.complete:hover {
        background: #15803d;
      }

      .field.highlight {
        background-color: rgba(37, 99, 235, 0.2);
        box-shadow: 0 0 0 2px #2563eb;
        z-index: 100;
      }

      /* Add styles for date input */
      .field-input[type="date"] {
        position: relative;
        padding-right: 2rem; /* Make room for the calendar icon */
        cursor: pointer;
        -webkit-appearance: none;
        appearance: none;
        height: 100%;
        min-height: 2rem;
        line-height: 1;
        display: flex;
        align-items: center;
      }

      .field-input[type="date"]::-webkit-calendar-picker-indicator {
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        width: 1.25rem;
        height: 1.25rem;
        padding: 0.25rem;
        cursor: pointer;
        opacity: 0.7;
        background: transparent;
      }

      .field-input[type="date"]::-webkit-calendar-picker-indicator:hover {
        opacity: 1;
      }

      /* Add a custom calendar icon for better visibility */
      .field-input[type="date"]::after {
        content: "";
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        width: 1.25rem;
        height: 1.25rem;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='%232563eb'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5'/%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
        pointer-events: none;
        opacity: 0.7;
      }

      /* Ensure the input is clickable on mobile */
      @media (max-width: 768px) {
        .field-input[type="date"] {
          padding-right: 2.5rem; /* Increase padding for better touch target */
          min-height: 2.5rem; /* Ensure minimum height for touch */
        }

        .field-input[type="date"]::-webkit-calendar-picker-indicator {
          width: 2rem;
          height: 2rem;
          padding: 0.5rem;
        }

        .field-input[type="date"]::after {
          width: 1.5rem;
          height: 1.5rem;
          right: 0.75rem;
        }
      }

      /* Add styles for other signed fields */
      .field.other-signed {
        background-color: transparent;
        pointer-events: none;
        opacity: 1;
      }

      .field.other-signed .field-input {
        color: #000000;
        background: transparent;
        border: none;
        pointer-events: none;
        height: 100%;
        display: flex;
        align-items: center;
      }

      .field.other-signed .field-input[type="date"]::after {
        display: none; /* Hide calendar icon for other signed fields */
      }

      .field.other-signed
        .field-input[type="date"]::-webkit-calendar-picker-indicator {
        display: none; /* Hide native calendar icon for other signed fields */
      }

      .field.other-signed .signature-preview {
        background-color: transparent;
        opacity: 1;
      }

      /* Add styles for prepopulated fields */
      .field.prepopulated {
        background-color: transparent;
        pointer-events: none;
        opacity: 1;
      }

      .field.prepopulated .field-input {
        color: #000000;
        background: transparent;
        border: none;
        pointer-events: none;
        height: 100%;
        display: flex;
        align-items: center;
        padding-right: 0.5rem;
      }

      .field.prepopulated .field-input[type="date"]::after {
        display: none;
      }

      .field.prepopulated
        .field-input[type="date"]::-webkit-calendar-picker-indicator {
        display: none;
      }

      .field.prepopulated .signature-preview {
        background-color: transparent;
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">Loading document...</div>
    </div>

    <!-- Header -->
    <div
      class="header"
      style="
        padding: 16px;
        border-bottom: 1px solid #e5e7eb;

        background: white;
      "
    >
      <div
        style="
          max-width: 1200px;
          margin: 0 auto;
          display: flex;
          justify-content: space-between;
          align-items: center;
          width: 100%;
        "
      >
        <div class="logo-container">
          <div
            style="
              font-size: 1.125rem;
              font-weight: 500;
              color: #2563eb;
              line-height: 1.75rem;
            "
          >
            Ezra Sign
          </div>
        </div>

        <div
          class="header-actions"
          style="display: flex; align-items: center; gap: 16px"
        >
          <button
            id="downloadPdfButton"
            style="
              padding: 8px 16px;
              background-color: inherit;
              color: #575757;
              border: 1px solid #575757;
              border-radius: 27px;
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
              transition: background-color 0.2s;
            "
          >
            Download PDF
          </button>
        </div>
      </div>
    </div>

    <!-- Navbar -->
    <nav class="navbar">
      <div class="navbar-content">
        <div class="navbar-title">Review and Complete Document</div>
        <div class="navbar-actions">
          <button class="action-button" id="actionButton" disabled>
            Start
          </button>
        </div>
      </div>
    </nav>

    <div class="container">
      <!-- <div
        id="alreadySignedNotification"
        class="already-signed-notification"
        style="display: none"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
        <span>You have already signed this document.</span>
      </div> -->
      <h1 class="document-title">Sign Document</h1>
      <div class="pdf-container">
        <div class="pdf-viewer" id="pdfViewer"></div>
      </div>
    </div>

    <!-- Add message container after navbar -->
    <div class="message-container" id="message"></div>
    <div class="message-container" id="criticalMessage"></div>

    <!-- Signature Modal -->
    <div class="modal" id="signatureModal">
      <div class="modal-content">
        <button class="btn-clear" id="clearSignature">Clear</button>
        <button class="modal-close" id="cancelSignature">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke-width="1.5"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        </button>
        <h2 class="modal-title">Draw Your Signature</h2>
        <div class="signature-canvas-container">
          <canvas id="signatureCanvas"></canvas>
        </div>
        <div class="signature-controls">
          <button class="btn-save" id="saveSignature">Save Signature</button>
        </div>
      </div>
    </div>

    <script>
      // Get API URL from environment
      const API_URL = window.ENV?.VITE_API_URL || 'https://ezra360sign-api.mnt.ezra360.com/api';
      //  const API_URL = window.ENV?.VITE_API_URL || "http://localhost:5000/api";

      // Initialize PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      // Global variables for document signing
      let documentId, token, email;
      let fields = []; // Add global fields variable

      // Add global variable for PDF URL
      let currentPdfUrl = "";

      // Add loading state management
      function showLoading(message = "Loading document...") {
        const overlay = document.getElementById("loadingOverlay");
        const loadingText = document.getElementById("loadingText");
        loadingText.textContent = message;
        overlay.classList.add("show");
      }

      function hideLoading() {
        const overlay = document.getElementById("loadingOverlay");
        overlay.classList.remove("show");
      }

      // Add validation state tracking
      let validationState = {
        requiredFields: new Set(),
        filledFields: new Set(),
        checkboxGroups: new Map(),
      };

      // Add validation functions
      function validateField(fieldId, value, type = "text") {
        const field = fields.find((f) => f._id === fieldId);
        if (!field) return;

        if (field.required) {
          if (type === "checkbox_group") {
            const selectedCount = value.length;
            const requiredSelections = field.checkboxGroup.requiredSelections;
            const maxSelections = field.checkboxGroup.maxSelections;

            if (selectedCount < requiredSelections) {
              validationState.filledFields.delete(fieldId);
            } else if (selectedCount > maxSelections) {
              validationState.filledFields.delete(fieldId);
            } else {
              validationState.filledFields.add(fieldId);
            }
          } else {
            if (value && value.trim() !== "") {
              validationState.filledFields.add(fieldId);
            } else {
              validationState.filledFields.delete(fieldId);
            }
          }
        }

        // Debug logging
        console.log("Field Validation:", {
          fieldId,
          value,
          type,
          isRequired: field.required,
          isFilled: validationState.filledFields.has(fieldId),
        });

        // Update button state after validation
        updateActionButton();
      }

      function updateActionButton() {
        const actionButton = document.getElementById("actionButton");
        if (!actionButton) return;

        // Get all editable required fields
        const editableRequiredFields = Array.from(
          validationState.requiredFields
        ).filter((fieldId) => {
          const fieldElement = document.querySelector(
            `[data-field-id="${fieldId}"]`
          );
          return (
            fieldElement && !fieldElement.classList.contains("prepopulated")
          );
        });

        // Check if all editable required fields are filled
        const allRequiredFieldsFilled = editableRequiredFields.every(
          (fieldId) => validationState.filledFields.has(fieldId)
        );

        // Debug logging
        console.log("Validation State:", {
          requiredFields: Array.from(validationState.requiredFields),
          filledFields: Array.from(validationState.filledFields),
          editableRequiredFields,
          allRequiredFieldsFilled,
          currentFieldIndex,
          totalFields: allFields.length,
        });

        if (currentFieldIndex === -1) {
          // Initial state - Start Document
          actionButton.textContent = "Start";
          actionButton.className = "action-button start";
          actionButton.disabled = false;
        } else if (
          currentFieldIndex >= allFields.length - 1 &&
          allRequiredFieldsFilled
        ) {
          // At last field AND all required fields are filled - Show Complete
          actionButton.textContent = "Sign Document";
          actionButton.className = "action-button complete";
          actionButton.disabled = false;
        } else {
          // Either not at last field OR not all required fields filled - Show Next Field
          actionButton.textContent = "Next Field";
          actionButton.className = "action-button next";
          actionButton.disabled = false;
        }
      }

      // Function to finalize field navigation after all pages are processed
      function finalizeFieldNavigation() {
        // Use setTimeout to allow resize observers to complete first
        setTimeout(() => {
          // Collect all navigable fields from all pages
          allFields = [];

          document.querySelectorAll(".field").forEach((fieldElement) => {
            // Skip fields that are prepopulated or disabled
            if (fieldElement.classList.contains("prepopulated")) {
              return;
            }

            const pageContainer = fieldElement.closest("[data-page-number]");
            if (pageContainer) {
              const pageNumber = parseInt(pageContainer.dataset.pageNumber);
              const rect = fieldElement.getBoundingClientRect();
              allFields.push({
                element: fieldElement,
                pageNumber,
                top: rect.top,
                left: rect.left,
              });
            }
          });

          // Sort fields by page number and position
          allFields.sort((a, b) => {
            if (a.pageNumber !== b.pageNumber) {
              return a.pageNumber - b.pageNumber;
            }
            if (a.top !== b.top) {
              return a.top - b.top;
            }
            return a.left - b.left;
          });

          // Reset current field index
          currentFieldIndex = -1;

          // Debug logging
          console.log("Final Validation State:", {
            requiredFields: Array.from(validationState.requiredFields),
            filledFields: Array.from(validationState.filledFields),
            navigableFields: allFields.length,
          });

          // Initialize action button
          updateActionButton();
        }, 100); // Small delay to allow resize observers to run
      }

      // Start the initialization when DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize signature canvas
        initializeSignatureCanvas();

        // Initialize the signing page
        initializeSigningPage();
      });

      // Initialize the signing page
      function initializeSigningPage() {
        // Clear any existing messages
        clearMessage();

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        token = urlParams.get("token");

        if (!token) {
          showError("Missing required token parameter");
          return;
        }

        // Add download button functionality
        const downloadButton = document.getElementById("downloadPdfButton");
        if (downloadButton) {
          downloadButton.addEventListener("click", () => {
            if (!currentPdfUrl) {
              showError("Document URL not available");
              return;
            }

            // Show loading state
            showLoading("Preparing document download...");

            // Fetch the PDF directly from the stored URL
            fetch(currentPdfUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.blob();
              })
              .then((blob) => {
                // Create a URL for the blob
                const url = window.URL.createObjectURL(blob);

                // Create a temporary link element
                const link = document.createElement("a");
                link.href = url;
                link.download = "document.pdf";

                // Append to body, click, and remove
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Clean up the URL
                window.URL.revokeObjectURL(url);

                // Hide loading state
                hideLoading();
              })
              .catch((error) => {
                hideLoading();
                showError("Error downloading document");
                console.error("Error:", error);
              });
          });
        }

        // Add action button functionality
        const actionButton = document.getElementById("actionButton");
        if (actionButton) {
          actionButton.addEventListener("click", handleActionButtonClick);
        }

        // Show loading state
        showLoading("Loading document data...");

        // Ensure button starts disabled
        const signButton = document.getElementById("signButton");
        if (signButton) {
          signButton.disabled = true;
          signButton.setAttribute("disabled", "disabled");
          signButton.style.pointerEvents = "none"; // Prevent any mouse interaction
        }

        // Initialize validation state
        validationState = {
          requiredFields: new Set(),
          filledFields: new Set(),
          checkboxGroups: new Map(),
        };

        // Fetch document data
        fetch(`${API_URL}/documents/signing/${token}`)
          .then((response) => response.json())
          .then((data) => {
            if (!data.success) {
              hideLoading();
              showError(data.message || "Error loading document");
              return;
            }

            const docData = data.data;
            window.docData = docData; // Store docData globally
            document.querySelector(
              ".document-title"
            ).textContent = `Sign Document: ${docData.title}`;
            fields = docData.fields;
            currentPdfUrl = docData.fileUrl; // Store the PDF URL

            // Check if document is already signed
            if (docData.isSigned) {
              showDocumentComplete();

              // Disable all fields
              document.querySelectorAll(".field").forEach((field) => {
                field.style.pointerEvents = "none";
                field.style.opacity = "0.7";
              });
            }

            // Update loading message
            showLoading("Rendering document...");

            // Load and display PDF
            loadPDF(docData.fileUrl, docData.fields);
          })
          .catch((error) => {
            hideLoading();
            showError("Error loading document");
            console.error(error);
          });
      }

      function loadPDF(url, fields) {
        // Initialize validation state ONCE at the beginning
        validationState = {
          requiredFields: new Set(),
          filledFields: new Set(),
          checkboxGroups: new Map(),
        };

        // Initialize allFields array
        allFields = [];

        console.log("Initializing PDF load with fields:", fields);

        pdfjsLib
          .getDocument({
            url: url,
            cMapUrl: "https://unpkg.com/pdfjs-dist@3.11.174/cmaps/",
            cMapPacked: true,
            standardFontDataUrl:
              "https://unpkg.com/pdfjs-dist@3.11.174/standard_fonts/",
            renderInteractiveForms: true,
            enableXfa: true,
            disableFontFace: false,
            useSystemFonts: true,
            maxCanvasPixels: 16777216, // Increase max canvas pixels
          })
          .promise.then((pdf) => {
            const viewer = document.getElementById("pdfViewer");
            viewer.innerHTML = "";

            // Create canvas for each page
            const renderPromises = [];
            for (let i = 1; i <= pdf.numPages; i++) {
              const pageContainer = document.createElement("div");
              pageContainer.style.position = "relative";
              pageContainer.style.marginBottom = "20px";
              pageContainer.dataset.pageNumber = i;

              const canvas = document.createElement("canvas");
              pageContainer.appendChild(canvas);
              viewer.appendChild(pageContainer);

              const renderPromise = pdf.getPage(i).then((page) => {
                // Increase scale for better quality
                const viewport = page.getViewport({ scale: 2.0 });
                const context = canvas.getContext("2d", { alpha: false });
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Enable high-quality rendering
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = "high";

                // Store original page dimensions for field positioning
                pageContainer.dataset.originalWidth = viewport.width;
                pageContainer.dataset.originalHeight = viewport.height;

                // Render PDF page with high quality settings
                return page
                  .render({
                    canvasContext: context,
                    viewport: viewport,
                    intent: "display",
                    renderInteractiveForms: true,
                    background: "white",
                    canvasFactory: {
                      create: function (width, height) {
                        const canvas = document.createElement("canvas");
                        canvas.width = width;
                        canvas.height = height;
                        return canvas;
                      },
                      reset: function (canvasAndContext, width, height) {
                        canvasAndContext.canvas.width = width;
                        canvasAndContext.canvas.height = height;
                      },
                      destroy: function (canvasAndContext) {
                        canvasAndContext.canvas.width = 0;
                        canvasAndContext.canvas.height = 0;
                      },
                    },
                  })
                  .promise.then(() => {
                    // Add fields for this page (but don't clear validation state)
                    const pageFields = fields.filter(
                      (field) => field.page === i
                    );
                    addFieldsToPage(pageContainer, pageFields, viewport);
                  });
              });

              renderPromises.push(renderPromise);
            }

            // Wait for all pages to render
            Promise.all(renderPromises)
              .then(() => {
                // After all pages are processed, finalize field navigation
                finalizeFieldNavigation();
                hideLoading();
              })
              .catch((error) => {
                hideLoading();
                showError("Error rendering PDF");
                console.error(error);
              });
          })
          .catch((error) => {
            hideLoading();
            showError("Error loading PDF");
            console.error(error);
          });
      }

      let signatureCanvas;
      let signatureContext;
      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      let currentField = null;

      // New function that doesn't clear validation state
      function addFieldsToPage(container, pageFields, viewport) {
        const originalWidth = parseFloat(container.dataset.originalWidth);
        const originalHeight = parseFloat(container.dataset.originalHeight);

        console.log(
          `Adding ${pageFields.length} fields to page ${container.dataset.pageNumber}`
        );

        // Function to create a field element
        function createFieldElement(field, isOtherSigned = false) {
          const fieldElement = document.createElement("div");
          const hasPrepopulatedValue =
            field.value ||
            field.dataURL ||
            (field.selectedOptions && field.selectedOptions.length > 0);

          fieldElement.className = `field ${
            field.type === "signature"
              ? "signature-field"
              : field.type === "checkbox_group"
              ? "checkbox-group-field"
              : ""
          } ${isOtherSigned || hasPrepopulatedValue ? "prepopulated" : ""}`;
          fieldElement.dataset.fieldId = field._id;

          // Calculate position and size based on original page dimensions
          const x = (field.x / 100) * originalWidth;
          const y = (field.y / 100) * originalHeight;
          const width = (field.width / 100) * originalWidth;
          const height = (field.height / 100) * originalHeight;

          fieldElement.style.left = `${x}px`;
          fieldElement.style.top = `${y}px`;
          fieldElement.style.width = `${width}px`;
          fieldElement.style.height = `${height}px`;

          // Add label only for non-checkbox fields
          if (field.type !== "checkbox_group") {
            const label = document.createElement("div");
            label.className = "field-label";
            label.textContent = field.label;
            if (field.color) {
              label.style.color = field.color;
            }
            if (field.fontSize) {
              label.style.fontSize = `${field.fontSize}px`;
            }
            if (field.font) {
              label.style.fontFamily = field.font;
            }
            fieldElement.appendChild(label);
          }

          // Add input based on field type
          if (field.type === "checkbox_group") {
            const checkboxContainer = document.createElement("div");
            checkboxContainer.className = "checkbox-group-container";
            checkboxContainer.dataset.fieldId = field._id;

            field.checkboxGroup.options.forEach((option) => {
              const optionContainer = document.createElement("div");
              optionContainer.className = "checkbox-option";

              const optionX = (option.x / 100) * width;
              const optionY = (option.y / 100) * height;
              optionContainer.style.left = `${optionX}px`;
              optionContainer.style.top = `${optionY}px`;

              const checkboxWidth = (option.width / 100) * width;
              const checkboxHeight = (option.height / 100) * height;
              optionContainer.style.width = `${checkboxWidth}px`;
              optionContainer.style.height = `${checkboxHeight}px`;

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.value = option.value;
              checkbox.name = `checkbox_${field._id}`;
              checkbox.dataset.fieldId = field._id;
              checkbox.dataset.optionValue = option.value;
              checkbox.disabled = isOtherSigned || hasPrepopulatedValue;

              if (
                field.selectedOptions &&
                field.selectedOptions.includes(option.value)
              ) {
                checkbox.checked = true;
              }

              // Add change event listener for checkbox
              if (!isOtherSigned && !hasPrepopulatedValue) {
                checkbox.addEventListener("change", () => {
                  const selectedOptions = Array.from(
                    checkboxContainer.querySelectorAll(
                      'input[type="checkbox"]:checked'
                    )
                  ).map((cb) => cb.dataset.optionValue);
                  validateField(field._id, selectedOptions, "checkbox_group");
                });
              }

              const optionLabel = document.createElement("label");
              optionLabel.textContent = option.label;
              optionLabel.htmlFor = `checkbox_${field._id}_${option._id}`;
              if (field.color) {
                optionLabel.style.color = field.color;
              }
              if (field.fontSize) {
                optionLabel.style.fontSize = `${field.fontSize}px`;
              }
              if (field.font) {
                optionLabel.style.fontFamily = field.font;
              }

              optionContainer.appendChild(checkbox);
              optionContainer.appendChild(optionLabel);
              checkboxContainer.appendChild(optionContainer);
            });

            fieldElement.appendChild(checkboxContainer);
          } else {
            const input = document.createElement("input");
            input.className = "field-input";
            input.type = field.type === "date" ? "date" : "text";
            input.required = field.required;
            input.dataset.fieldId = field._id;
            input.placeholder = field.label;
            input.disabled = isOtherSigned || hasPrepopulatedValue;

            // Set value if it exists
            if (field.value) {
              input.value = field.value;
              if (field.type === "date" && field.value) {
                const date = new Date(field.value);
                if (!isNaN(date.getTime())) {
                  const year = date.getFullYear();
                  const month = String(date.getMonth() + 1).padStart(2, "0");
                  const day = String(date.getDate()).padStart(2, "0");
                  input.value = `${year}-${month}-${day}`;
                }
              }
            }

            // Add input event listeners for text and date fields
            if (!isOtherSigned && !hasPrepopulatedValue) {
              input.addEventListener("input", () => {
                validateField(field._id, input.value, field.type);
              });
              input.addEventListener("change", () => {
                validateField(field._id, input.value, field.type);
              });
            }

            // Calculate font size based on field height
            const fieldHeight = (field.height / 100) * originalHeight;
            const fontSize = Math.max(fieldHeight * 0.4, 12);
            input.style.fontSize = `${fontSize}px`;

            // Apply color and font family
            if (field.color) {
              input.style.color = field.color;
            }
            if (field.font) {
              input.style.fontFamily = field.font;
            }

            if (field.type === "signature") {
              input.style.display = "none";
              const signaturePreview = document.createElement("div");
              signaturePreview.className = "signature-preview";

              if (field.value && field.value.startsWith("data:image")) {
                signaturePreview.style.backgroundImage = `url(${field.value})`;
                signaturePreview.style.backgroundColor = "transparent";
                signaturePreview.textContent = "";
              } else if (field.value === "signed") {
                signaturePreview.textContent = "Signed";
              } else {
                signaturePreview.textContent =
                  isOtherSigned || hasPrepopulatedValue ? "" : "Click to sign";
              }

              if (field.color) {
                signaturePreview.style.color = field.color;
              }
              if (field.font) {
                signaturePreview.style.fontFamily = field.font;
              }
              fieldElement.appendChild(signaturePreview);

              if (!isOtherSigned && !hasPrepopulatedValue) {
                fieldElement.addEventListener("click", () =>
                  showSignatureModal(field)
                );
              }
            }

            if (field.type === "date") {
              input.type = "date";
              input.placeholder = "MM/DD/YYYY";
              input.style.minHeight = "100%";
              input.style.height = "100%";
              input.style.display = "flex";
              input.style.alignItems = "center";
            }

            fieldElement.appendChild(input);
          }

          return fieldElement;
        }

        // Process each field on this page
        pageFields.forEach((field) => {
          const hasPrepopulatedValue =
            field.value ||
            field.dataURL ||
            (field.selectedOptions && field.selectedOptions.length > 0);

          // Add to validation state if the field is required and not prepopulated
          if (field.required && !hasPrepopulatedValue) {
            validationState.requiredFields.add(field._id);
            console.log(
              `Added required field to validation: ${field.label} (${field._id})`
            );
          }

          // If field has a prepopulated value or is already filled, mark as filled
          if (hasPrepopulatedValue && field.required) {
            validationState.filledFields.add(field._id);
            console.log(
              `Pre-filled required field: ${field.label} (${field._id})`
            );
          }

          const fieldElement = createFieldElement(field);
          container.appendChild(fieldElement);
        });

        // Add other signed fields if they exist
        if (window.docData && window.docData.otherSignedFields) {
          window.docData.otherSignedFields.forEach((signedData) => {
            signedData.fields.forEach((field) => {
              if (field.page === parseInt(container.dataset.pageNumber)) {
                const fieldElement = createFieldElement(field, true);
                container.appendChild(fieldElement);
              }
            });
          });
        }

        // Add resize observer to update field positions when container size changes
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const container = entry.target;
            const canvas = container.querySelector("canvas");
            if (!canvas) return;

            const scale = canvas.offsetWidth / originalWidth;

            container.querySelectorAll(".field").forEach((fieldElement) => {
              const fieldId = fieldElement.dataset.fieldId;

              // Find field data from current page fields or other signed fields
              let field = pageFields.find((f) => f._id === fieldId);
              if (!field && window.docData?.otherSignedFields) {
                field = window.docData.otherSignedFields
                  .flatMap((s) => s.fields)
                  .find((f) => f._id === fieldId);
              }

              if (field) {
                const x = (field.x / 100) * originalWidth;
                const y = (field.y / 100) * originalHeight;
                const width = (field.width / 100) * originalWidth;
                const height = (field.height / 100) * originalHeight;

                const newX = x * scale;
                const newY = y * scale;
                const newWidth = width * scale;
                const newHeight = height * scale;

                fieldElement.style.left = `${newX}px`;
                fieldElement.style.top = `${newY}px`;
                fieldElement.style.width = `${newWidth}px`;
                fieldElement.style.height = `${newHeight}px`;

                // Handle checkbox group resizing
                if (field.type === "checkbox_group") {
                  const checkboxContainer = fieldElement.querySelector(
                    ".checkbox-group-container"
                  );
                  if (checkboxContainer && field.checkboxGroup.options) {
                    field.checkboxGroup.options.forEach((option, index) => {
                      const optionContainer = checkboxContainer.children[index];
                      if (optionContainer) {
                        const optionX = (option.x / 100) * newWidth;
                        const optionY = (option.y / 100) * newHeight;
                        const optionWidth = (option.width / 100) * newWidth;
                        const optionHeight = (option.height / 100) * newHeight;

                        optionContainer.style.left = `${optionX}px`;
                        optionContainer.style.top = `${optionY}px`;
                        optionContainer.style.width = `${optionWidth}px`;
                        optionContainer.style.height = `${optionHeight}px`;

                        const checkbox = optionContainer.querySelector(
                          "input[type='checkbox']"
                        );
                        if (checkbox) {
                          checkbox.style.width = `${optionWidth}px`;
                          checkbox.style.height = `${optionHeight}px`;
                        }
                      }
                    });
                  }
                }
              }
            });
          }
        });

        resizeObserver.observe(container);
      }

      function initializeSignatureCanvas() {
        signatureCanvas = document.getElementById("signatureCanvas");
        signatureContext = signatureCanvas.getContext("2d", { alpha: true });

        // Set canvas size to match container
        const container = signatureCanvas.parentElement;
        signatureCanvas.width = container.offsetWidth;
        signatureCanvas.height = container.offsetHeight;

        // Set up drawing properties
        signatureContext.strokeStyle = "#000000";
        signatureContext.lineWidth = 2;
        signatureContext.lineCap = "round";
        signatureContext.lineJoin = "round";

        // Clear the canvas with transparency
        clearSignature();

        // Event listeners for drawing
        signatureCanvas.addEventListener("mousedown", startDrawing);
        signatureCanvas.addEventListener("mousemove", draw);
        signatureCanvas.addEventListener("mouseup", stopDrawing);
        signatureCanvas.addEventListener("mouseout", stopDrawing);

        // Touch support
        signatureCanvas.addEventListener("touchstart", handleTouch);
        signatureCanvas.addEventListener("touchmove", handleTouch);
        signatureCanvas.addEventListener("touchend", stopDrawing);
      }

      function startDrawing(e) {
        e.preventDefault();
        isDrawing = true;
        const pos = getPosition(e);
        lastX = pos.x;
        lastY = pos.y;

        // Start a new path
        signatureContext.beginPath();
        signatureContext.moveTo(lastX, lastY);
      }

      function draw(e) {
        e.preventDefault();
        if (!isDrawing) return;

        const pos = getPosition(e);

        // Draw a line to the new position
        signatureContext.lineTo(pos.x, pos.y);
        signatureContext.stroke();

        lastX = pos.x;
        lastY = pos.y;
      }

      function stopDrawing(e) {
        e.preventDefault();
        isDrawing = false;
      }

      function handleTouch(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
          e.type === "touchstart" ? "mousedown" : "mousemove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY,
          }
        );
        signatureCanvas.dispatchEvent(mouseEvent);
      }

      function getPosition(e) {
        const rect = signatureCanvas.getBoundingClientRect();
        const scaleX = signatureCanvas.width / rect.width;
        const scaleY = signatureCanvas.height / rect.height;

        let x, y;

        if (e.type.includes("touch")) {
          x = e.touches[0].clientX;
          y = e.touches[0].clientY;
        } else {
          x = e.clientX;
          y = e.clientY;
        }

        return {
          x: (x - rect.left) * scaleX,
          y: (y - rect.top) * scaleY,
        };
      }

      function clearSignature() {
        // Clear with transparency
        signatureContext.clearRect(
          0,
          0,
          signatureCanvas.width,
          signatureCanvas.height
        );
        signatureContext.strokeStyle = "#000000";
        signatureContext.lineWidth = 2;
      }

      function showSignatureModal(field) {
        currentField = field;
        const modal = document.getElementById("signatureModal");
        modal.classList.add("show");

        // Reinitialize the canvas when showing the modal
        setTimeout(() => {
          initializeSignatureCanvas();
        }, 0);
      }

      function hideSignatureModal() {
        document.getElementById("signatureModal").classList.remove("show");
        currentField = null;
      }

      function saveSignature() {
        if (currentField) {
          // Get the signature data with transparency
          const signatureData = signatureCanvas.toDataURL("image/png");
          const fieldElement = document.querySelector(
            `[data-field-id="${currentField._id}"]`
          );
          if (fieldElement) {
            fieldElement.value = signatureData;
            const preview =
              fieldElement.parentElement.querySelector(".signature-preview");
            if (preview) {
              preview.style.backgroundImage = `url(${signatureData})`;
              preview.style.backgroundColor = "transparent";
              preview.textContent = "";
              // Validate signature field
              validateField(currentField._id, "signed");
              // Move to next field after signing
              goToNextField();
            }
          }
        }
        hideSignatureModal();
      }

      // Initialize signature canvas when DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
        // Add event listeners for signature modal buttons
        document
          .getElementById("clearSignature")
          .addEventListener("click", clearSignature);
        document
          .getElementById("saveSignature")
          .addEventListener("click", saveSignature);
        document
          .getElementById("cancelSignature")
          .addEventListener("click", hideSignatureModal);
      });

      function addFields(container, fields, viewport) {
        const originalWidth = parseFloat(container.dataset.originalWidth);
        const originalHeight = parseFloat(container.dataset.originalHeight);

        // Clear validation state before adding fields
        validationState = {
          requiredFields: new Set(),
          filledFields: new Set(),
          checkboxGroups: new Map(),
        };

        // Function to create a field element
        function createFieldElement(field, isOtherSigned = false) {
          const fieldElement = document.createElement("div");
          const hasPrepopulatedValue =
            field.value ||
            field.dataURL ||
            (field.selectedOptions && field.selectedOptions.length > 0);

          fieldElement.className = `field ${
            field.type === "signature"
              ? "signature-field"
              : field.type === "checkbox_group"
              ? "checkbox-group-field"
              : ""
          } ${isOtherSigned || hasPrepopulatedValue ? "prepopulated" : ""}`;
          fieldElement.dataset.fieldId = field._id;

          // Calculate position and size based on original page dimensions
          const x = (field.x / 100) * originalWidth;
          const y = (field.y / 100) * originalHeight;
          const width = (field.width / 100) * originalWidth;
          const height = (field.height / 100) * originalHeight;

          fieldElement.style.left = `${x}px`;
          fieldElement.style.top = `${y}px`;
          fieldElement.style.width = `${width}px`;
          fieldElement.style.height = `${height}px`;

          // Add label only for non-checkbox fields
          if (field.type !== "checkbox_group") {
            const label = document.createElement("div");
            label.className = "field-label";
            label.textContent = field.label;
            if (field.color) {
              label.style.color = field.color;
            }
            if (field.fontSize) {
              label.style.fontSize = `${field.fontSize}px`;
            }
            if (field.font) {
              label.style.fontFamily = field.font;
            }
            fieldElement.appendChild(label);
          }

          // Add input based on field type
          if (field.type === "checkbox_group") {
            const checkboxContainer = document.createElement("div");
            checkboxContainer.className = "checkbox-group-container";
            checkboxContainer.dataset.fieldId = field._id;

            field.checkboxGroup.options.forEach((option) => {
              const optionContainer = document.createElement("div");
              optionContainer.className = "checkbox-option";

              const optionX = (option.x / 100) * width;
              const optionY = (option.y / 100) * height;
              optionContainer.style.left = `${optionX}px`;
              optionContainer.style.top = `${optionY}px`;

              const checkboxWidth = (option.width / 100) * width;
              const checkboxHeight = (option.height / 100) * height;
              optionContainer.style.width = `${checkboxWidth}px`;
              optionContainer.style.height = `${checkboxHeight}px`;

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.value = option.value;
              checkbox.name = `checkbox_${field._id}`;
              checkbox.dataset.fieldId = field._id;
              checkbox.dataset.optionValue = option.value;
              checkbox.disabled = isOtherSigned || hasPrepopulatedValue;

              if (
                field.selectedOptions &&
                field.selectedOptions.includes(option.value)
              ) {
                checkbox.checked = true;
              }

              // Add change event listener for checkbox
              if (!isOtherSigned && !hasPrepopulatedValue) {
                checkbox.addEventListener("change", () => {
                  const selectedOptions = Array.from(
                    checkboxContainer.querySelectorAll(
                      'input[type="checkbox"]:checked'
                    )
                  ).map((cb) => cb.dataset.optionValue);
                  validateField(field._id, selectedOptions, "checkbox_group");
                });
              }

              const optionLabel = document.createElement("label");
              optionLabel.textContent = option.label;
              optionLabel.htmlFor = `checkbox_${field._id}_${option._id}`;
              if (field.color) {
                optionLabel.style.color = field.color;
              }
              if (field.fontSize) {
                optionLabel.style.fontSize = `${field.fontSize}px`;
              }
              if (field.font) {
                optionLabel.style.fontFamily = field.font;
              }

              optionContainer.appendChild(checkbox);
              optionContainer.appendChild(optionLabel);
              checkboxContainer.appendChild(optionContainer);
            });

            fieldElement.appendChild(checkboxContainer);
          } else {
            const input = document.createElement("input");
            input.className = "field-input";
            input.type = field.type === "date" ? "date" : "text";
            input.required = field.required;
            input.dataset.fieldId = field._id;
            input.placeholder = field.label;
            input.disabled = isOtherSigned || hasPrepopulatedValue;

            // Set value if it exists
            if (field.value) {
              input.value = field.value;
              if (field.type === "date" && field.value) {
                const date = new Date(field.value);
                if (!isNaN(date.getTime())) {
                  const year = date.getFullYear();
                  const month = String(date.getMonth() + 1).padStart(2, "0");
                  const day = String(date.getDate()).padStart(2, "0");
                  input.value = `${year}-${month}-${day}`;
                }
              }
            }

            // Add input event listeners for text and date fields
            if (!isOtherSigned && !hasPrepopulatedValue) {
              input.addEventListener("input", () => {
                validateField(field._id, input.value, field.type);
              });
              input.addEventListener("change", () => {
                validateField(field._id, input.value, field.type);
              });
            }

            // Calculate font size based on field height
            const fieldHeight = (field.height / 100) * originalHeight;
            const fontSize = Math.max(fieldHeight * 0.4, 12);
            input.style.fontSize = `${fontSize}px`;

            // Apply color and font family
            if (field.color) {
              input.style.color = field.color;
            }
            if (field.font) {
              input.style.fontFamily = field.font;
            }

            if (field.type === "signature") {
              input.style.display = "none";
              const signaturePreview = document.createElement("div");
              signaturePreview.className = "signature-preview";

              if (field.value && field.value.startsWith("data:image")) {
                signaturePreview.style.backgroundImage = `url(${field.value})`;
                signaturePreview.style.backgroundColor = "transparent";
                signaturePreview.textContent = "";
              } else if (field.value === "signed") {
                signaturePreview.textContent = "Signed";
              } else {
                signaturePreview.textContent =
                  isOtherSigned || hasPrepopulatedValue ? "" : "Click to sign";
              }

              if (field.color) {
                signaturePreview.style.color = field.color;
              }
              if (field.font) {
                signaturePreview.style.fontFamily = field.font;
              }
              fieldElement.appendChild(signaturePreview);

              if (!isOtherSigned && !hasPrepopulatedValue) {
                fieldElement.addEventListener("click", () =>
                  showSignatureModal(field)
                );
              }
            }

            if (field.type === "date") {
              input.type = "date";
              input.placeholder = "MM/DD/YYYY";
              input.style.minHeight = "100%";
              input.style.height = "100%";
              input.style.display = "flex";
              input.style.alignItems = "center";
            }

            fieldElement.appendChild(input);
          }

          return fieldElement;
        }

        // Add current fields and populate validation state
        fields.forEach((field) => {
          const hasPrepopulatedValue =
            field.value ||
            field.dataURL ||
            (field.selectedOptions && field.selectedOptions.length > 0);

          // Add to validation state if the field is required and not prepopulated
          if (field.required && !hasPrepopulatedValue) {
            validationState.requiredFields.add(field._id);
            console.log(
              `Added required field to validation: ${field.label} (${field._id})`
            );
          }

          // If field has a prepopulated value or is already filled, mark as filled
          if (hasPrepopulatedValue) {
            if (field.required) {
              validationState.filledFields.add(field._id);
              console.log(
                `Pre-filled required field: ${field.label} (${field._id})`
              );
            }
          }

          const fieldElement = createFieldElement(field);
          container.appendChild(fieldElement);
        });

        // Collect all fields in order for navigation (only non-prepopulated fields)
        allFields = [];
        fields.forEach((field) => {
          const hasPrepopulatedValue =
            field.value ||
            field.dataURL ||
            (field.selectedOptions && field.selectedOptions.length > 0);

          if (!hasPrepopulatedValue) {
            const fieldElement = document.querySelector(
              `[data-field-id="${field._id}"]`
            );
            if (
              fieldElement &&
              !fieldElement.classList.contains("prepopulated")
            ) {
              const pageNumber = parseInt(
                fieldElement.closest("[data-page-number]").dataset.pageNumber
              );
              const rect = fieldElement.getBoundingClientRect();
              allFields.push({
                element: fieldElement,
                pageNumber,
                top: rect.top,
                left: rect.left,
              });
            }
          }
        });

        // Sort fields by page number and position
        allFields.sort((a, b) => {
          if (a.pageNumber !== b.pageNumber) {
            return a.pageNumber - b.pageNumber;
          }
          if (a.top !== b.top) {
            return a.top - b.top;
          }
          return a.left - b.left;
        });

        // Debug logging
        console.log("Fields Added - Validation State:", {
          totalFields: fields.length,
          requiredFields: Array.from(validationState.requiredFields),
          filledFields: Array.from(validationState.filledFields),
          navigableFields: allFields.length,
          prepopulatedFields: fields.filter(
            (f) =>
              f.value ||
              f.dataURL ||
              (f.selectedOptions && f.selectedOptions.length > 0)
          ).length,
        });

        // Add other signed fields if they exist
        if (window.docData && window.docData.otherSignedFields) {
          window.docData.otherSignedFields.forEach((signedData) => {
            signedData.fields.forEach((field) => {
              if (field.page === parseInt(container.dataset.pageNumber)) {
                const fieldElement = createFieldElement(field, true);
                container.appendChild(fieldElement);
              }
            });
          });
        }

        // Add resize observer to update field positions when container size changes
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const container = entry.target;
            const canvas = container.querySelector("canvas");
            if (!canvas) return;

            const scale = canvas.offsetWidth / originalWidth;

            container.querySelectorAll(".field").forEach((fieldElement) => {
              const field =
                fields.find((f) => f._id === fieldElement.dataset.fieldId) ||
                window.docData?.otherSignedFields
                  ?.flatMap((s) => s.fields)
                  .find((f) => f._id === fieldElement.dataset.fieldId);

              if (field) {
                const x = (field.x / 100) * originalWidth;
                const y = (field.y / 100) * originalHeight;
                const width = (field.width / 100) * originalWidth;
                const height = (field.height / 100) * originalHeight;

                const newX = x * scale;
                const newY = y * scale;
                const newWidth = width * scale;
                const newHeight = height * scale;

                fieldElement.style.left = `${newX}px`;
                fieldElement.style.top = `${newY}px`;
                fieldElement.style.width = `${newWidth}px`;
                fieldElement.style.height = `${newHeight}px`;

                if (field.type === "checkbox_group") {
                  const checkboxContainer = fieldElement.querySelector(
                    ".checkbox-group-container"
                  );
                  if (checkboxContainer) {
                    field.checkboxGroup.options.forEach((option, index) => {
                      const optionContainer = checkboxContainer.children[index];
                      if (optionContainer) {
                        const optionX = (option.x / 100) * newWidth;
                        const optionY = (option.y / 100) * newHeight;
                        const optionWidth = (option.width / 100) * newWidth;
                        const optionHeight = (option.height / 100) * newHeight;

                        optionContainer.style.left = `${optionX}px`;
                        optionContainer.style.top = `${optionY}px`;
                        optionContainer.style.width = `${optionWidth}px`;
                        optionContainer.style.height = `${optionHeight}px`;

                        const checkbox = optionContainer.querySelector(
                          "input[type='checkbox']"
                        );
                        if (checkbox) {
                          checkbox.style.width = `${optionWidth}px`;
                          checkbox.style.height = `${optionHeight}px`;
                        }
                      }
                    });
                  }
                }
              }
            });
          }
        });

        resizeObserver.observe(container);

        // Update button state after all fields are added
        updateActionButton();
      }

      function showError(message) {
        const navbar = document.querySelector(".navbar");
        const navbarTitle = document.querySelector(".navbar-title");
        const navbarActions = document.querySelector(".navbar-actions");

        navbar.classList.add("notification", "error");
        navbarTitle.textContent = message;
        navbarActions.style.display = "none";

        // Remove notification after 5 seconds
        setTimeout(() => {
          navbar.classList.remove("notification", "error");
          navbarTitle.textContent = "Review and Complete Document";
          navbarActions.style.display = "flex";
        }, 5000);
      }

      function showSuccess(message) {
        const navbar = document.querySelector(".navbar");
        const navbarTitle = document.querySelector(".navbar-title");
        const navbarActions = document.querySelector(".navbar-actions");

        navbar.classList.add("notification", "success");
        navbarTitle.textContent = message;
        navbarActions.style.display = "none";

        // Remove notification after 5 seconds
        setTimeout(() => {
          navbar.classList.remove("notification", "success");
          navbarTitle.textContent = "Review and Complete Document";
          navbarActions.style.display = "flex";
        }, 5000);
      }

      function showDocumentComplete() {
        const navbar = document.querySelector(".navbar");
        const navbarTitle = document.querySelector(".navbar-title");
        const navbarActions = document.querySelector(".navbar-actions");

        navbar.classList.add("notification", "success");
        navbarTitle.textContent = "Document Complete!";
        navbarActions.style.display = "none";
      }

      // Add a function to clear messages
      function clearMessage() {
        document.getElementById("message").innerHTML = "";
      }

      // Handle sign button click
      function handleActionButtonClick() {
        const actionButton = document.getElementById("actionButton");
        if (!actionButton || actionButton.disabled) {
          return;
        }

        if (currentFieldIndex === -1) {
          // Start document - go to first field
          highlightField(0);
        } else if (currentFieldIndex >= allFields.length - 1) {
          const allRequiredFieldsFilled = Array.from(
            validationState.requiredFields
          ).every((fieldId) => validationState.filledFields.has(fieldId));

          if (allRequiredFieldsFilled) {
            // Complete document - submit the form
            showLoading("Signing document...");

            const fieldValues = [];
            let validationError = false;

            // Handle text and date fields
            document.querySelectorAll(".field-input").forEach((input) => {
              const fieldId = input.dataset.fieldId;
              const field = fields.find((f) => f._id === fieldId);

              // Skip signature fields as they are handled separately
              if (field && field.type !== "signature") {
                fieldValues.push({
                  fieldId: fieldId,
                  value: input.value,
                  selectedOptions: [], // Empty array for non-checkbox fields
                  dataURL: null, // No dataURL for text/date fields
                });
              }
            });

            // Handle signature fields
            document.querySelectorAll(".signature-field").forEach((field) => {
              const fieldId = field.dataset.fieldId;
              const signaturePreview =
                field.querySelector(".signature-preview");
              const dataURL = signaturePreview.style.backgroundImage;

              if (dataURL && dataURL !== "none") {
                // Extract the dataURL from the style
                const extractedDataURL = dataURL.replace(
                  /^url\(['"](.+)['"]\)$/,
                  "$1"
                );

                fieldValues.push({
                  fieldId: fieldId,
                  value: "signed",
                  selectedOptions: [],
                  dataURL: extractedDataURL,
                });
              } else {
                fieldValues.push({
                  fieldId: fieldId,
                  value: "",
                  selectedOptions: [],
                  dataURL: null,
                });
              }
            });

            // Handle checkbox group values
            document
              .querySelectorAll(".checkbox-group-container")
              .forEach((container) => {
                const fieldId = container.dataset.fieldId;
                const field = fields.find((f) => f._id === fieldId);
                const selectedOptions = Array.from(
                  container.querySelectorAll('input[type="checkbox"]:checked')
                ).map((checkbox) => checkbox.dataset.optionValue);

                if (field && field.type === "checkbox_group") {
                  const selectedCount = selectedOptions.length;
                  const requiredSelections =
                    field.checkboxGroup.requiredSelections;
                  const maxSelections = field.checkboxGroup.maxSelections;

                  // Validate required selections
                  if (field.required && selectedCount < requiredSelections) {
                    showError(
                      `Please select at least ${requiredSelections} option(s) for ${field.label}`
                    );
                    validationError = true;
                    return;
                  }

                  // Validate maximum selections
                  if (selectedCount > maxSelections) {
                    showError(
                      `Please select at most ${maxSelections} option(s) for ${field.label}`
                    );
                    validationError = true;
                    return;
                  }

                  fieldValues.push({
                    fieldId,
                    value: null,
                    selectedOptions: selectedOptions,
                    dataURL: null,
                  });
                }
              });

            // If there was a validation error, don't proceed with submission
            if (validationError) {
              hideLoading();
              return;
            }

            // Generate the signed PDF and send to server
            generateSignedPDF(fieldValues)
              .then((pdfBlob) => {
                // Create FormData
                const formData = new FormData();
                formData.append("signedPdf", pdfBlob, "signed_document.pdf");
                formData.append("fieldValues", JSON.stringify(fieldValues));

                // Send signature request with the signed PDF
                fetch(`${API_URL}/documents/sign/${token}`, {
                  method: "PUT",
                  body: formData,
                  headers: {
                    Accept: "application/json",
                  },
                })
                  .then((response) => {
                    if (!response.ok) {
                      throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                  })
                  .then((data) => {
                    hideLoading();
                    if (data.success) {
                      showDocumentComplete();
                      actionButton.disabled = true;
                      actionButton.setAttribute("disabled", "disabled");

                      // Disable all fields
                      document.querySelectorAll(".field").forEach((field) => {
                        field.style.pointerEvents = "none";
                        field.style.opacity = "0.7";
                      });
                    } else {
                      showError(data.message);
                      console.error("Server response:", data);
                    }
                  })
                  .catch((error) => {
                    hideLoading();
                    showError("Error signing document: " + error.message);
                    console.error(error);
                  });
              })
              .catch((error) => {
                hideLoading();
                showError("Error generating signed PDF");
                console.error(error);
              });
          } else {
            // Go back to first field
            highlightField(0);
          }
        } else {
          // Next field
          goToNextField();
        }
      }

      // Add function to generate signed PDF with correct positioning and formatting
      async function generateSignedPDF(fieldValues) {
        console.log("Starting PDF generation with field values:", fieldValues);
        return new Promise(async (resolve, reject) => {
          try {
            // Load the original PDF
            const response = await fetch(currentPdfUrl);
            const existingPdfBytes = await response.arrayBuffer();

            // Create PDF document from existing PDF to preserve original layout
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.load(existingPdfBytes, {
              updateMetadata: false, // Disable metadata updates to reduce size
            });

            // Embed fonts
            const helveticaFont = await pdfDoc.embedFont(
              StandardFonts.Helvetica
            );
            const helveticaBoldFont = await pdfDoc.embedFont(
              StandardFonts.HelveticaBold
            );
            const timesRomanFont = await pdfDoc.embedFont(
              StandardFonts.TimesRoman
            );

            // Get pages
            const pages = pdfDoc.getPages();

            // Process current signer's field values
            for (const fieldValue of fieldValues) {
              const field = fields.find((f) => f._id === fieldValue.fieldId);
              if (!field) {
                console.warn(`Field not found for ID: ${fieldValue.fieldId}`);
                continue;
              }

              console.log(
                `Processing current signer field: ${field.label} (${field.type}) on page ${field.page}`
              );

              const pageIndex = field.page - 1; // Convert to 0-based index
              if (pageIndex < 0 || pageIndex >= pages.length) {
                console.warn(
                  `Invalid page index ${pageIndex} for field ${field.label}`
                );
                continue;
              }

              const page = pages[pageIndex];
              const { width: pageWidth, height: pageHeight } = page.getSize();

              console.log(
                `Page ${field.page} dimensions: ${pageWidth} x ${pageHeight}`
              );

              // Calculate field position and size based on percentage values from API
              // Note: PDF coordinate system has origin at bottom-left, so we need to flip Y
              const fieldX = (field.x / 100) * pageWidth;
              const fieldY =
                pageHeight -
                (field.y / 100) * pageHeight -
                (field.height / 100) * pageHeight;
              const fieldWidth = (field.width / 100) * pageWidth;
              const fieldHeight = (field.height / 100) * pageHeight;

              console.log(
                `Field ${field.label} position: x=${fieldX}, y=${fieldY}, w=${fieldWidth}, h=${fieldHeight}`
              );

              // Calculate font size based on field configuration or field height
              let fontSize;
              if (field.fontSize) {
                // Try different scaling approaches based on your display setup
                // Option 1: Direct use (if fontSize in API is already PDF-ready)
                // fontSize = field.fontSize;

                // Option 2: Scale down from display size (since display uses scale 2.0)
                fontSize = field.fontSize / 2;

                // Option 3: More conservative scaling
                // fontSize = field.fontSize * 0.6;

                // Option 4: DPI-based scaling
                // fontSize = field.fontSize * (72 / 96);

                fontSize = Math.max(fontSize, 4); // Minimum readable size
              } else {
                // Fallback: calculate font size based on field height
                fontSize = Math.max(fieldHeight * 0.5, 6);
              }

              console.log(
                `Field ${field.label} font size: API=${field.fontSize}, PDF=${fontSize}, fieldHeight=${fieldHeight}`
              );

              // Get font based on field configuration
              let font = helveticaFont;
              if (field.font) {
                switch (field.font.toLowerCase()) {
                  case "arial":
                  case "helvetica":
                    font = helveticaFont;
                    break;
                  case "times":
                  case "times new roman":
                    font = timesRomanFont;
                    break;
                  default:
                    font = helveticaFont;
                }
              }

              // Get color from field configuration
              let textColor = rgb(0, 0, 0); // Default black
              if (field.color && field.color.startsWith("#")) {
                const hex = field.color.slice(1);
                const r = parseInt(hex.slice(0, 2), 16) / 255;
                const g = parseInt(hex.slice(2, 4), 16) / 255;
                const b = parseInt(hex.slice(4, 6), 16) / 255;
                textColor = rgb(r, g, b);
              }

              // Handle different field types
              if (field.type === "text" || field.type === "date") {
                if (fieldValue.value && fieldValue.value.trim() !== "") {
                  // Calculate text position within field (vertically centered)
                  const textY = fieldY + fieldHeight / 2 - fontSize / 2;

                  try {
                    page.drawText(fieldValue.value, {
                      x: fieldX + 4, // Small padding from left edge
                      y: textY,
                      size: fontSize,
                      font: font,
                      color: textColor,
                      maxWidth: fieldWidth - 8, // Account for padding
                    });
                  } catch (error) {
                    console.warn(
                      `Error drawing text for field ${field._id}:`,
                      error
                    );
                    // Fallback with simpler options
                    page.drawText(fieldValue.value, {
                      x: fieldX + 4,
                      y: textY,
                      size: fontSize,
                      color: textColor,
                    });
                  }
                }
              }

              // Handle checkbox groups
              else if (
                field.type === "checkbox_group" &&
                fieldValue.selectedOptions &&
                fieldValue.selectedOptions.length > 0
              ) {
                fieldValue.selectedOptions.forEach((optionValue) => {
                  const option = field.checkboxGroup.options.find(
                    (opt) => opt.value === optionValue
                  );
                  if (option) {
                    // Calculate checkbox position relative to the field
                    const checkboxX = fieldX + (option.x / 100) * fieldWidth;
                    const checkboxY =
                      fieldY +
                      fieldHeight -
                      (option.y / 100) * fieldHeight -
                      (option.height / 100) * fieldHeight;
                    const checkboxWidth = (option.width / 100) * fieldWidth;
                    const checkboxHeight = (option.height / 100) * fieldHeight;

                    // Calculate checkmark size
                    const checkmarkSize =
                      Math.min(checkboxWidth, checkboxHeight) * 0.8;

                    // Position checkmark in center of checkbox
                    const checkmarkX =
                      checkboxX + checkboxWidth / 2 - checkmarkSize / 4;
                    const checkmarkY =
                      checkboxY + checkboxHeight / 2 - checkmarkSize / 4;

                    try {
                      page.drawText("âœ“", {
                        x: checkmarkX,
                        y: checkmarkY,
                        size: checkmarkSize,
                        font: helveticaBoldFont,
                        color: textColor,
                      });
                    } catch (error) {
                      console.warn(
                        `Error drawing checkbox for field ${field._id}:`,
                        error
                      );
                    }
                  }
                });
              }

              // Handle signatures
              else if (field.type === "signature" && fieldValue.dataURL) {
                try {
                  // Convert data URL to bytes
                  const base64Data = fieldValue.dataURL.split(",")[1];
                  const imageBytes = Uint8Array.from(atob(base64Data), (c) =>
                    c.charCodeAt(0)
                  );

                  // Embed the signature image
                  const signatureImage = await pdfDoc.embedPng(imageBytes);

                  // Get image dimensions and calculate aspect ratio
                  const { width: imgWidth, height: imgHeight } =
                    signatureImage.scale(1);
                  const aspectRatio = imgWidth / imgHeight;

                  // Calculate signature size to fit within field while maintaining aspect ratio
                  let sigWidth = fieldWidth - 8; // Account for padding
                  let sigHeight = sigWidth / aspectRatio;

                  // If height is too large, scale based on height instead
                  if (sigHeight > fieldHeight - 8) {
                    sigHeight = fieldHeight - 8;
                    sigWidth = sigHeight * aspectRatio;
                  }

                  // Center the signature within the field
                  const sigX = fieldX + (fieldWidth - sigWidth) / 2;
                  const sigY = fieldY + (fieldHeight - sigHeight) / 2;

                  page.drawImage(signatureImage, {
                    x: sigX,
                    y: sigY,
                    width: sigWidth,
                    height: sigHeight,
                    opacity: 1.0,
                  });
                } catch (error) {
                  console.error(
                    `Error embedding signature for field ${field._id}:`,
                    error
                  );
                  // Fallback: draw "Signed" text
                  const textY = fieldY + fieldHeight / 2 - fontSize / 2;
                  page.drawText("Signed", {
                    x: fieldX + 4,
                    y: textY,
                    size: fontSize,
                    font: font,
                    color: textColor,
                  });
                }
              }
            }

            // Now process fields from other signers (otherSignedFields)
            if (window.docData && window.docData.otherSignedFields) {
              console.log(
                `Processing ${window.docData.otherSignedFields.length} other signers' fields`
              );

              for (const otherSigner of window.docData.otherSignedFields) {
                console.log(
                  `Processing fields for ${otherSigner.recipient.name} (${otherSigner.recipient.signerType})`
                );

                for (const field of otherSigner.fields) {
                  console.log(
                    `Processing other signer field: ${field.label} (${field.type}) on page ${field.page}`
                  );

                  const pageIndex = field.page - 1; // Convert to 0-based index
                  if (pageIndex < 0 || pageIndex >= pages.length) {
                    console.warn(
                      `Invalid page index ${pageIndex} for field ${field.label}`
                    );
                    continue;
                  }

                  const page = pages[pageIndex];
                  const { width: pageWidth, height: pageHeight } =
                    page.getSize();

                  // Calculate field position and size based on percentage values from API
                  const fieldX = (field.x / 100) * pageWidth;
                  const fieldY =
                    pageHeight -
                    (field.y / 100) * pageHeight -
                    (field.height / 100) * pageHeight;
                  const fieldWidth = (field.width / 100) * pageWidth;
                  const fieldHeight = (field.height / 100) * pageHeight;

                  console.log(
                    `Other field ${field.label} position: x=${fieldX}, y=${fieldY}, w=${fieldWidth}, h=${fieldHeight}`
                  );

                  // Calculate font size
                  let fontSize;
                  if (field.fontSize) {
                    fontSize = field.fontSize / 2;
                    fontSize = Math.max(fontSize, 4);
                  } else {
                    fontSize = Math.max(fieldHeight * 0.5, 6);
                  }

                  // Get font
                  let font = helveticaFont;
                  if (field.font) {
                    switch (field.font.toLowerCase()) {
                      case "arial":
                      case "helvetica":
                        font = helveticaFont;
                        break;
                      case "times":
                      case "times new roman":
                        font = timesRomanFont;
                        break;
                      default:
                        font = helveticaFont;
                    }
                  }

                  // Get color
                  let textColor = rgb(0, 0, 0);
                  if (field.color && field.color.startsWith("#")) {
                    const hex = field.color.slice(1);
                    const r = parseInt(hex.slice(0, 2), 16) / 255;
                    const g = parseInt(hex.slice(2, 4), 16) / 255;
                    const b = parseInt(hex.slice(4, 6), 16) / 255;
                    textColor = rgb(r, g, b);
                  }

                  // Handle different field types for other signers
                  if (field.type === "text" || field.type === "date") {
                    if (field.value && field.value.trim() !== "") {
                      const textY = fieldY + fieldHeight / 2 - fontSize / 2;

                      try {
                        page.drawText(field.value, {
                          x: fieldX + 4,
                          y: textY,
                          size: fontSize,
                          font: font,
                          color: textColor,
                          maxWidth: fieldWidth - 8,
                        });
                      } catch (error) {
                        console.warn(
                          `Error drawing text for other signer field ${field._id}:`,
                          error
                        );
                        page.drawText(field.value, {
                          x: fieldX + 4,
                          y: textY,
                          size: fontSize,
                          color: textColor,
                        });
                      }
                    }
                  }

                  // Handle checkbox groups for other signers
                  else if (
                    field.type === "checkbox_group" &&
                    field.selectedOptions &&
                    field.selectedOptions.length > 0
                  ) {
                    field.selectedOptions.forEach((optionValue) => {
                      const option = field.checkboxGroup.options.find(
                        (opt) => opt.value === optionValue
                      );
                      if (option) {
                        const checkboxX =
                          fieldX + (option.x / 100) * fieldWidth;
                        const checkboxY =
                          fieldY +
                          fieldHeight -
                          (option.y / 100) * fieldHeight -
                          (option.height / 100) * fieldHeight;
                        const checkboxWidth = (option.width / 100) * fieldWidth;
                        const checkboxHeight =
                          (option.height / 100) * fieldHeight;

                        const checkmarkSize =
                          Math.min(checkboxWidth, checkboxHeight) * 0.8;
                        const checkmarkX =
                          checkboxX + checkboxWidth / 2 - checkmarkSize / 4;
                        const checkmarkY =
                          checkboxY + checkboxHeight / 2 - checkmarkSize / 4;

                        try {
                          page.drawText("âœ“", {
                            x: checkmarkX,
                            y: checkmarkY,
                            size: checkmarkSize,
                            font: helveticaBoldFont,
                            color: textColor,
                          });
                        } catch (error) {
                          console.warn(
                            `Error drawing checkbox for other signer field ${field._id}:`,
                            error
                          );
                        }
                      }
                    });
                  }

                  // Handle signatures for other signers
                  else if (
                    field.type === "signature" &&
                    field.value &&
                    field.value.startsWith("data:image")
                  ) {
                    try {
                      const base64Data = field.value.split(",")[1];
                      const imageBytes = Uint8Array.from(
                        atob(base64Data),
                        (c) => c.charCodeAt(0)
                      );

                      const signatureImage = await pdfDoc.embedPng(imageBytes);
                      const { width: imgWidth, height: imgHeight } =
                        signatureImage.scale(1);
                      const aspectRatio = imgWidth / imgHeight;

                      let sigWidth = fieldWidth - 8;
                      let sigHeight = sigWidth / aspectRatio;

                      if (sigHeight > fieldHeight - 8) {
                        sigHeight = fieldHeight - 8;
                        sigWidth = sigHeight * aspectRatio;
                      }

                      const sigX = fieldX + (fieldWidth - sigWidth) / 2;
                      const sigY = fieldY + (fieldHeight - sigHeight) / 2;

                      page.drawImage(signatureImage, {
                        x: sigX,
                        y: sigY,
                        width: sigWidth,
                        height: sigHeight,
                        opacity: 1.0,
                      });
                    } catch (error) {
                      console.error(
                        `Error embedding signature for other signer field ${field._id}:`,
                        error
                      );
                      const textY = fieldY + fieldHeight / 2 - fontSize / 2;
                      page.drawText("Signed", {
                        x: fieldX + 4,
                        y: textY,
                        size: fontSize,
                        font: font,
                        color: textColor,
                      });
                    }
                  }
                }
              }
            }

            // Save the PDF with aggressive compression settings
            const pdfBytes = await pdfDoc.save({
              useObjectStreams: true,
              addDefaultPage: false,
              updateFieldAppearances: false,
              compress: true,
              objectsPerTick: 50, // Reduce memory usage
              updateMetadata: false, // Disable metadata updates
            });

            // Create a Blob from the PDF bytes
            const pdfBlob = new Blob([pdfBytes], { type: "application/pdf" });
            resolve(pdfBlob);
          } catch (error) {
            console.error("Error in generateSignedPDF:", error);
            reject(error);
          }
        });
      }

      // Add after the existing global variables
      let currentFieldIndex = -1;
      let allFields = [];

      // Add after the existing functions
      function initializeFieldNavigation() {
        // Collect all fields in order
        allFields = [];
        document.querySelectorAll(".field").forEach((field) => {
          // Skip fields that are prepopulated or disabled
          if (field.classList.contains("prepopulated")) {
            return;
          }

          const pageNumber = parseInt(
            field.closest("[data-page-number]").dataset.pageNumber
          );
          const rect = field.getBoundingClientRect();
          allFields.push({
            element: field,
            pageNumber,
            top: rect.top,
            left: rect.left,
          });
        });

        // Sort fields by page number and position
        allFields.sort((a, b) => {
          if (a.pageNumber !== b.pageNumber) {
            return a.pageNumber - b.pageNumber;
          }
          if (a.top !== b.top) {
            return a.top - b.top;
          }
          return a.left - b.left;
        });

        // Initialize action button
        updateActionButton();
      }

      function highlightField(index) {
        // Remove highlight from current field
        if (currentFieldIndex >= 0 && currentFieldIndex < allFields.length) {
          allFields[currentFieldIndex].element.classList.remove("highlight");
        }

        // Update current index and highlight new field
        currentFieldIndex = index;
        if (currentFieldIndex >= 0 && currentFieldIndex < allFields.length) {
          const field = allFields[currentFieldIndex];
          field.element.classList.add("highlight");

          // Scroll field into view
          field.element.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });

          // Focus the field if it's an input
          const input = field.element.querySelector("input");
          if (input) {
            input.focus();
          } else if (field.element.classList.contains("signature-field")) {
            // For signature fields, show the signature modal
            const fieldData = fields.find(
              (f) => f._id === field.element.dataset.fieldId
            );
            if (fieldData) {
              showSignatureModal(fieldData);
            }
          }
        }

        // Always update button state when changing fields
        updateActionButton();
      }

      function goToNextField() {
        if (
          currentFieldIndex >= 0 &&
          currentFieldIndex < allFields.length - 1
        ) {
          // Go to next field
          highlightField(currentFieldIndex + 1);
        } else if (currentFieldIndex === allFields.length - 1) {
          // If we're at the last field, go back to first field
          highlightField(0);
        }
      }
    </script>
  </body>
</html>
